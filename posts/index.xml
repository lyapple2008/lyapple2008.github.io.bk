<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on BeYoung</title>
    <link>https://lyapple2008.github.io/posts/</link>
    <description>Recent content in Posts on BeYoung</description>
    <image>
      <title>BeYoung</title>
      <url>https://lyapple2008.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://lyapple2008.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.152.2</generator>
    <language>zh</language>
    <copyright>See this site&amp;rsquo;s source code here, licensed under GPLv3 ·</copyright>
    <lastBuildDate>Sun, 22 Feb 2026 09:43:54 +0800</lastBuildDate>
    <atom:link href="https://lyapple2008.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【置顶】2026</title>
      <link>https://lyapple2008.github.io/posts/2026-todo/</link>
      <pubDate>Sun, 22 Feb 2026 09:43:54 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/2026-todo/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;记录跟踪2026年要做的事情和正在做的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;目标&#34;&gt;目标&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;健康生活&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 体重减到60kg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;探索可能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 英语能力，熟练3篇演讲短文&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 独立开发，目标完成4个独立项目&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 公众号输出，目标输出文章10篇&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;正在做的项目&#34;&gt;正在做的项目&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; iOS双语字幕App&lt;/p&gt;</description>
      <content:encoded><![CDATA[<blockquote>
<p>记录跟踪2026年要做的事情和正在做的事情。</p>
</blockquote>
<h1 id="目标">目标</h1>
<ul>
<li>
<p>健康生活</p>
<ul>
<li><input disabled="" type="checkbox"> 体重减到60kg</li>
</ul>
</li>
<li>
<p>探索可能</p>
<ul>
<li><input disabled="" type="checkbox"> 英语能力，熟练3篇演讲短文</li>
<li><input disabled="" type="checkbox"> 独立开发，目标完成4个独立项目</li>
<li><input disabled="" type="checkbox"> 公众号输出，目标输出文章10篇</li>
</ul>
</li>
</ul>
<h1 id="正在做的项目">正在做的项目</h1>
<ul>
<li>
<p><input disabled="" type="checkbox"> iOS双语字幕App</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 30天每天一万步（2026.02.22~2026.03.22）</p>
</li>
<li>
<p><input disabled="" type="checkbox"> 五万资产配置计划</p>
</li>
</ul>
<!--
---
一些想法
1. 普通绘本变成点读书，或者可交互的书
2. 就某一个主题与GPT的多轮对话，经常会思路分叉，做一个工具汇总整理这些对话
3. 电子书阅读器支持TTS
4. 照片管理应用，如何方便的整理和管理大量照片
5. 拼了还拼小游戏外挂

---
-->
]]></content:encoded>
    </item>
    <item>
      <title>ASR任务初体验</title>
      <link>https://lyapple2008.github.io/posts/202602/2026-02-14-asr%E4%BB%BB%E5%8A%A1%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sat, 14 Feb 2026 17:59:07 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202602/2026-02-14-asr%E4%BB%BB%E5%8A%A1%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇继续是开发日志，正在开发一款iOS端的实时双语字幕APP，由于需要用到语音识别，了解了下语音识别任务的现状和主流方案，为后面方案选择做准备。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<blockquote>
<p>这篇继续是开发日志，正在开发一款iOS端的实时双语字幕APP，由于需要用到语音识别，了解了下语音识别任务的现状和主流方案，为后面方案选择做准备。</p>
</blockquote>
<h3 id="模块流程">模块流程</h3>

<div class="mermaid">graph LR
    A[捕获系统播放音频] --&gt; B[语音识别ASR]
    B --&gt; C[语言翻译]
    B --&gt; D[双语字幕]
    C --&gt; D</div>
<h1 id="什么是asr任务">什么是ASR任务</h1>
<p>ASR（Automatic Speech Recognition，自动语音识别）任务，指的是将连续的音频信号转换为对应的文本序列的过程。这是一种典型的序列到序列（Sequence-to-Sequence）的转换任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">audio (连续信号)  →  text (离散 token)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>从信号处理的角度来看，传统ASR需要解决以下核心问题：</p>
<ol>
<li><strong>声学建模</strong>：将音频特征映射到音素或字符</li>
<li><strong>语言建模</strong>：捕捉词汇之间的概率关系</li>
<li><strong>对齐问题</strong>：音频帧与输出token之间的对齐</li>
</ol>
<p>不过，在现代端到端深度学习方案中，这三个问题都被统一在一个神经网络中解决，不再需要独立的声学模型和语言模型。模型通过端到端训练自动学习如何从音频特征直接映射到文本输出。</p>
<h1 id="与降噪任务的区别">与降噪任务的区别</h1>
<p>在开发iOS双语字幕的过程中，我之前可能接触过降噪任务，这两者有本质区别：</p>
<table>
  <thead>
      <tr>
          <th>维度</th>
          <th>降噪任务</th>
          <th>ASR任务</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>输入输出</strong></td>
          <td>音频 → 音频</td>
          <td>音频 → 文本</td>
      </tr>
      <tr>
          <td><strong>任务类型</strong></td>
          <td>信号回归</td>
          <td>序列到序列</td>
      </tr>
      <tr>
          <td><strong>评估指标</strong></td>
          <td>SNR、PESQ</td>
          <td>WER、CER</td>
      </tr>
      <tr>
          <td><strong>难点</strong></td>
          <td>保留语音质量</td>
          <td>识别准确性</td>
      </tr>
      <tr>
          <td><strong>模型结构</strong></td>
          <td>Encoder</td>
          <td>Encoder-Decoder</td>
      </tr>
  </tbody>
</table>
<p>简单来说：</p>
<ul>
<li><strong>降噪任务</strong>：输入一段有噪声的音频，输出干净的音频（同类转换）</li>
<li><strong>ASR任务</strong>：输入音频，输出文字（跨模态转换）</li>
</ul>
<p>ASR的难点在于它需要&quot;理解&quot;音频内容并转换为语义符号，而不是简单地处理信号波形。同时，ASR任务的输入和输出也不像降噪任务那样是一一对应的关系，还需要处理对齐问题。</p>
<h1 id="目前主流的实现方案">目前主流的实现方案</h1>
<p>主流的ASR实现方案主要有三种：CTC、RNN-T和基于Attention的Seq2Seq。</p>
<h2 id="ctc-connectionist-temporal-classification">CTC (Connectionist Temporal Classification)</h2>
<p>CTC是一种经典的对齐方法，核心思想是<strong>不需要显式的对齐标签</strong>，而是通过&quot;blank&quot;机制自动学习对齐。</p>
<p>CTC引入了空白符（blank）和折叠机制：</p>
<ul>
<li>重复的字符会被折叠（如 &ldquo;aaabbb&rdquo; → &ldquo;ab&rdquo;）</li>
<li>blank符号不产生任何输出</li>
<li>通过动态规划计算所有可能路径的概率</li>
</ul>
<p><a href="https://distill.pub/2017/ctc/">Sequence Modeling With CTC</a> 详细原理可参考这篇文章。</p>
<p>训练阶段就是使目标token序列路径的概率最大，而推理阶段就是搜索概率最大的token路径并输出，这里通常有两种方法：</p>
<table>
  <thead>
      <tr>
          <th>方法</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Greedy Search</strong></td>
          <td>每一步都选择概率最大的token输出</td>
      </tr>
      <tr>
          <td><strong>Beam Search</strong></td>
          <td>每一步保留top-N概率的token结果，输出token序列路径概率最大的结果</td>
      </tr>
  </tbody>
</table>
<h2 id="rnn-t-recurrent-neural-network-transducer">RNN-T (Recurrent Neural Network Transducer)</h2>
<p>RNN-T是CTC的扩展，引入了一个额外的预测网络（Prediction Network）来建模输出token之间的依赖关系。</p>
<p>RNN-T由三部分组成：</p>
<ol>
<li><strong>编码器（Encoder）</strong>：将音频特征转换为声学表征</li>
<li><strong>预测网络（Prediction Network）</strong>：基于已输出的token预测下一个token</li>
<li><strong>联合网络（Joint Network）</strong>：结合Encoder和Prediction的输出，预测下一个token</li>
</ol>
<p>RNN-T在输出时，不仅会输入当前帧音频数据，还会输入历史输出作为参考</p>
<h2 id="seq2seq-with-attention">Seq2Seq with Attention</h2>
<p>基于Attention机制的序列到序列模型是目前最流行的方案，被广泛用于Whisper、Paraformer等现代ASR系统。</p>
<h3 id="原理">原理</h3>
<p>经典结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Encoder → Attention → Decoder → Output</span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li><strong>Encoder</strong>：将音频特征编码为高维表征（通常使用Transformer或Conformer）</li>
<li><strong>Attention</strong>：让Decoder在生成每个token时&quot;关注&quot;输入的不同部分</li>
<li><strong>Decoder</strong>：自回归生成输出文本</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>可以建模任意长度序列的依赖关系</li>
<li>识别准确率高</li>
<li>易于添加语言模型集成</li>
<li>适合大规模预训练</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>推理延迟较高（需要完整音频或较大chunk）</li>
<li>流式识别实现复杂</li>
<li>计算资源需求大</li>
</ul>
<h1 id="流式模型和非流式模型">流式模型和非流式模型</h1>
<p>流式（Streaming）和非流式（Offline）是ASR系统根据实时性要求的两种设计模式。</p>
<h2 id="什么是非流式模型">什么是非流式模型</h2>
<p>非流式模型（Offline ASR）需要<strong>等待完整音频输入后才能开始识别</strong>。</p>
<p>特点：</p>
<ul>
<li>输入：完整的音频文件或长音频段</li>
<li>延迟：较高，需要等待音频结束</li>
<li>准确率：通常较高，因为可以看到完整的上下文</li>
<li>适用场景：视频字幕生成、会议转录、录音文件处理</li>
</ul>
<h2 id="什么是流式模型">什么是流式模型</h2>
<p>流式模型（Streaming ASR）可以<strong>边接收音频输入边输出识别结果</strong>，实现实时识别。</p>
<p>特点：</p>
<ul>
<li>输入：连续的音频流（通常是短片段，如30ms一帧）</li>
<li>延迟：低，可以做到几百毫秒内输出</li>
<li>准确率：通常略低于非流式，因为只有历史和部分未来上下文</li>
<li>适用场景：实时语音对话、语音助手、直播字幕</li>
</ul>
<h2 id="技术实现差异">技术实现差异</h2>
<table>
  <thead>
      <tr>
          <th>维度</th>
          <th>流式模型</th>
          <th>非流式模型</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>上下文</strong></td>
          <td>有限上下文（lookahead）</td>
          <td>完整上下文</td>
      </tr>
      <tr>
          <td><strong>延迟</strong></td>
          <td>低（&lt;500ms）</td>
          <td>高</td>
      </tr>
      <tr>
          <td><strong>准确率</strong></td>
          <td>略低</td>
          <td>较高</td>
      </tr>
      <tr>
          <td><strong>模型复杂度</strong></td>
          <td>较高（需处理分段）</td>
          <td>较低</td>
      </tr>
      <tr>
          <td><strong>内存占用</strong></td>
          <td>较小</td>
          <td>较大</td>
      </tr>
  </tbody>
</table>
<p>流式模型通常需要特殊设计，如：</p>
<ul>
<li><strong>Chunked Attention</strong>：将音频分成小块处理</li>
<li><strong>CTC Prefix</strong>：使用CTC的前缀解码</li>
<li><strong>Lookahead</strong>：只考虑有限的未来帧</li>
</ul>
<hr>
<h1 id="自回归解码和非自回归解码">自回归解码和非自回归解码</h1>
<p>解码方式决定了模型如何生成输出文本。</p>
<h2 id="自回归解码-autoregressive-decoding">自回归解码 (Autoregressive Decoding)</h2>
<p>自回归解码是目前最主流的方式，特点是<strong>逐 token 生成，每个 token 的生成依赖之前所有生成的 token</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输出: &#34;hello world&#34;
</span></span><span class="line"><span class="cl">生成过程:
</span></span><span class="line"><span class="cl">  1. 生成 &#34;h&#34;
</span></span><span class="line"><span class="cl">  2. 基于 &#34;h&#34; 生成 &#34;he&#34;
</span></span><span class="line"><span class="cl">  3. 基于 &#34;he&#34; 生成 &#34;hel&#34;
</span></span><span class="line"><span class="cl">  4. ...</span></span></code></pre></td></tr></table>
</div>
</div>
<p>特点：</p>
<ul>
<li><strong>优点</strong>：生成质量高，可以建模长期依赖</li>
<li><strong>缺点</strong>：串行生成，推理速度慢（O(n) 复杂度，n为输出长度）</li>
<li>典型模型：Transformer Decoder、RNN-T</li>
</ul>
<h2 id="非自回归解码-non-autoregressive-decoding">非自回归解码 (Non-autoregressive Decoding)</h2>
<p>非自回归解码是一种<strong>并行生成</strong>方式，一次性输出整个序列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">输出: &#34;hello world&#34;
</span></span><span class="line"><span class="cl">生成过程:
</span></span><span class="line"><span class="cl">  1. 直接输出完整句子 &#34;hello world&#34;</span></span></code></pre></td></tr></table>
</div>
</div>
<p>特点：</p>
<ul>
<li><strong>优点</strong>：并行生成，推理速度快（O(1) 复杂度）</li>
<li><strong>缺点</strong>：难以建模输出token之间的依赖，生成质量可能较低</li>
<li>典型实现：CTC、FastCorrect、Mask-Predict</li>
</ul>
<h2 id="对比">对比</h2>
<table>
  <thead>
      <tr>
          <th>维度</th>
          <th>自回归解码</th>
          <th>非自回归解码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>生成方式</strong></td>
          <td>串行，逐token</td>
          <td>并行，一次性输出</td>
      </tr>
      <tr>
          <td><strong>推理速度</strong></td>
          <td>慢</td>
          <td>快</td>
      </tr>
      <tr>
          <td><strong>生成质量</strong></td>
          <td>高</td>
          <td>略低</td>
      </tr>
      <tr>
          <td><strong>依赖关系</strong></td>
          <td>建模token间依赖</td>
          <td>假设条件独立</td>
      </tr>
      <tr>
          <td><strong>典型模型</strong></td>
          <td>RNN-T、Seq2Seq</td>
          <td>CTC、FastConformer</td>
      </tr>
  </tbody>
</table>
<h1 id="方案选择">方案选择</h1>
<p>OK，前面了解了这么多，都是为了后续实现最小原型产品，选择语音识别方案做准备，目标不是要训练一个SOTA模型，因此这里暂时只是粗浅的了解。</p>
<p>根据需求分析：</p>
<ul>
<li><strong>目标设备</strong>：iOS移动端（资源有限）</li>
<li><strong>语言支持</strong>：多语言</li>
<li><strong>实时性</strong>：实时输入音频，实时输出文字</li>
</ul>
<h2 id="选择优先级">选择优先级</h2>
<ol>
<li><strong>首先能跑</strong>：模型大小和计算量必须在移动端可承受范围内</li>
<li><strong>然后多语言</strong>：需要支持多种语言识别</li>
<li><strong>最后准确率</strong>：在功能可用后再优化性能</li>
</ol>
<h2 id="优先级一模型能在移动端跑起来">优先级一：模型能在移动端跑起来</h2>
<h3 id="参数量选择">参数量选择</h3>
<p>移动端资源有限，模型参数量直接决定了能否运行。这里暂时没有明确的数值界限，实际运行起来再看，后面也可以用量化技术缩小模型体积。</p>
<p><strong>量化技术</strong>：INT8量化可将模型体积缩小约4倍，准确率损失通常&lt;5%；INT4可进一步缩小到1/8，但准确率下降更明显。</p>
<h3 id="架构选择">架构选择</h3>
<table>
  <thead>
      <tr>
          <th>架构</th>
          <th>计算量</th>
          <th>内存占用</th>
          <th>移动端适用性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Transformer Encoder</strong></td>
          <td>中</td>
          <td>中</td>
          <td>★★★★☆</td>
      </tr>
      <tr>
          <td><strong>Conformer</strong></td>
          <td>中高</td>
          <td>中</td>
          <td>★★★★☆</td>
      </tr>
      <tr>
          <td><strong>RNN/LSTM</strong></td>
          <td>低</td>
          <td>低</td>
          <td>★★★☆☆</td>
      </tr>
  </tbody>
</table>
<p><strong>建议</strong>：选择Encoder-only或轻量级的Conformer结构，参数量控制在50M以内。</p>
<h2 id="优先级二支持多语言">优先级二：支持多语言</h2>
<p>确认模型能在移动端运行后，需要考虑多语言支持能力。</p>
<h3 id="不同模型架构的多语言能力">不同模型架构的多语言能力</h3>
<table>
  <thead>
      <tr>
          <th>模型架构</th>
          <th>多语言支持</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>端到端Seq2Seq</strong></td>
          <td>★★★★★</td>
          <td>训练时使用多语言数据，自然支持多语言</td>
      </tr>
      <tr>
          <td><strong>RNN-T</strong></td>
          <td>★★★☆☆</td>
          <td>可支持，但需要针对性训练多语言版本</td>
      </tr>
      <tr>
          <td><strong>CTC</strong></td>
          <td>★★☆☆☆</td>
          <td>通常针对单一语言，多语言版本较少</td>
      </tr>
  </tbody>
</table>
<h3 id="结论">结论</h3>
<p>需要支持多语言时，<strong>优先选择端到端Seq2Seq架构</strong>，这类模型的预训练版本通常已支持数十到上百种语言。</p>
<h2 id="优先级三实时性要求">优先级三：实时性要求</h2>
<p>实时字幕要求模型能够在接收音频的同时输出文字。</p>
<h3 id="流式-vs-非流式">流式 vs 非流式</h3>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>延迟</th>
          <th>实现难度</th>
          <th>实时字幕适用性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>流式模型</strong></td>
          <td>&lt;500ms</td>
          <td>高</td>
          <td>★★★★★</td>
      </tr>
      <tr>
          <td><strong>非流式模型</strong></td>
          <td>&gt;1s</td>
          <td>低</td>
          <td>★★☆☆☆</td>
      </tr>
  </tbody>
</table>
<p><strong>折中方案</strong>：使用非流式模型时，可通过&quot;分块处理&quot;策略模拟流式效果：</p>
<ul>
<li>将音频切分为固定长度的chunk（如1秒）</li>
<li>逐块识别并拼接结果</li>
<li>通过缓存历史上下文减少误差</li>
</ul>
<h3 id="解码方式">解码方式</h3>
<table>
  <thead>
      <tr>
          <th>解码方式</th>
          <th>延迟</th>
          <th>实现复杂度</th>
          <th>实时性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>非自回归（Greedy）</strong></td>
          <td>低</td>
          <td>简单</td>
          <td>★★★★★</td>
      </tr>
      <tr>
          <td><strong>非自回归（Beam Search）</strong></td>
          <td>中</td>
          <td>中</td>
          <td>★★★★☆</td>
      </tr>
      <tr>
          <td><strong>自回归</strong></td>
          <td>高</td>
          <td>复杂</td>
          <td>★★☆☆☆</td>
      </tr>
  </tbody>
</table>
<p><strong>建议</strong>：实时场景优先选择<strong>非自回归解码</strong>（Greedy），延迟最低。</p>
<h2 id="总结">总结</h2>
<p><strong>核心理念</strong>：先完成端到端流程验证，再根据实际体验进行针对性优化。移动端ASR是一个迭代过程，不必追求一步到位。</p>
<p>后续我会记录在iOS端的具体实现过程，各位道友记得点赞追番哦。</p>
<p><img alt="各位道友记得一键三连" loading="lazy" src="/images/%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E.jpg"></p>
]]></content:encoded>
    </item>
    <item>
      <title>关于AICoding的一些感想和后续的规划</title>
      <link>https://lyapple2008.github.io/posts/202601/2026-02-01-%E5%85%B3%E4%BA%8Eaicoding%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E5%92%8C%E5%90%8E%E7%BB%AD%E7%9A%84%E8%A7%84%E5%88%92/</link>
      <pubDate>Sun, 01 Feb 2026 09:28:45 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202601/2026-02-01-%E5%85%B3%E4%BA%8Eaicoding%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3%E5%92%8C%E5%90%8E%E7%BB%AD%E7%9A%84%E8%A7%84%E5%88%92/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近要说最热最火的话题，那一定是 AI，而其中 AI 应用场景 AI Coding 也是发展迅速，大有替代程序员的势头。最近几个月一直在使用 AI Coding，心态上经历了最初的「完了，失业要提前了」，到「稳了，还能苟几年」。下面就分享一些使用上的感受，以及面对 AI Coding 这股后浪，这个号后面的一些规划。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<blockquote>
<p>最近要说最热最火的话题，那一定是 AI，而其中 AI 应用场景 AI Coding 也是发展迅速，大有替代程序员的势头。最近几个月一直在使用 AI Coding，心态上经历了最初的「完了，失业要提前了」，到「稳了，还能苟几年」。下面就分享一些使用上的感受，以及面对 AI Coding 这股后浪，这个号后面的一些规划。</p>
</blockquote>
<p><img alt="程序员使用 AI 编码提升效率" loading="lazy" src="/images/2026-02-01/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BD%BF%E7%94%A8AI%E7%BC%96%E7%A0%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87.jpg"></p>
<h3 id="1-ai-coding-非常有帮助收费的优于免费的">1. AI Coding 非常有帮助，收费的优于免费的</h3>
<p>这几年 AI 发展迅速，早已不是当年的「人工智障」了，确实是可以作为生产力工具帮忙提升效率的。对于 AI Coding 来说，到底能提升多少效率，取决于多方面因素：比如 Coding 在日常开发中占的比重、使用 AI 的熟练程度、AI Coding 工具本身的性能等等。但不管怎么说，AI Coding 对于程序员来说都是有正向作用的，是值得花时间去用起来的。</p>
<p>我自己用得比较多的是 Cursor 跟 Claude Code。Cursor 是公司给配置的，Claude Code 是我自己订阅了 MiniMax 的 Coding Plan 配置的。在此之前也用过国内一些免费的 AI Coding 工具（比如 Trae 和 Qcoder），短暂的使用给我的感受就是没有付费的好用，一个问题反复折腾好几轮都没有跑通。</p>
<p>当然这些纯粹是个人拍脑袋的感受，使用时间不长，也没有很深入地去使用。网上也有一些使用 Trae 和 Qcoder 做出可用应用的案例。重要的是 AI Coding 确实能够提升开发效率的，大家都应该用起来。</p>
<h3 id="2-ai-coding-的能力约等于使用者自身">2. AI Coding 的能力约等于使用者自身</h3>
<p><img alt="AI Coding 能力边界" loading="lazy" src="/images/2026-02-01/1770474310208.jpg"></p>
<p>AI Coding 在目前这个阶段还是一个被动的工具，需要使用者去给它进行规划和任务指引，因此使用者的能力边界就约等于使用 AI Coding 后的能力边界。</p>
<p>程序开发是一个复杂的系统工程，每个需求拆分任务后就有很多步骤。就算 AI Coding 每一步的成功率为 95%，8 步之后最终能成功的概率也只剩下 66%。另外，AI Coding 获取的需求信息主要来源于使用者，使用者在与 AI 沟通描述时，这里又得损耗一些性能，导致成功率下降。不过好消息是，使用者可以在与 AI 互动过程中不断扩展自己的能力边界，把原来了解的领域变成熟悉领域，所以理论上 AI Coding 是没有边界的。</p>
<p>这里给我几点启发：</p>
<ol>
<li>生产环境只在自己熟悉的范围内使用，最多只触及到了解的区域，再往外扩展能得到什么成果就只能听天由命了，试验性的尝试性的项目不受这个限制。</li>
<li>给 AI 描述需求时，尽可能详细，就像你自己开发一样，想好整个代码的架构和目标，并记录成文档。文档不仅可以给 AI 描述需求，也可以随时给 AI 找回上下文，弥补 AI Coding 上下文有限的问题。</li>
<li>大龄程序员凭借多年积累的经验，辅以AI Coding弥补”编程体力不足“，又可以焕发第二春了。</li>
</ol>
<h3 id="3-ai-coding-还只是辅助编程使用者需要为其质量兜底">3. AI Coding 还只是辅助编程，使用者需要为其质量兜底</h3>
<p><img alt="AI 与程序员" loading="lazy" src="/images/2026-02-01/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A2%ABAI%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6%E6%8B%A6%E4%BD%8F%E7%BD%9A%E6%AC%BE.png"></p>
<p>类似于汽车自动驾驶，AI Coding 现在也还只是 L2 水平，辅助编程阶段，出了事故还是得使用者来负责。所以对于生产环境使用 AI Coding 时，要对 AI Coding 生成的代码进行严格的 Review。</p>
<p>不过最近也看到另一种解法：随着 AI Coding 生成的代码量级快速上升，传统逐行代码 Review 的方式已经不太现实，而且效率不高。所以也有不 Review 只测试的方式来验收 AI Coding 生成的代码，在修改和生成代码的同时，让AI也生成对应的单元测试，人类负责把关单元测试的通过情况，可能也许也是一种可行的AI Coding协同方式。</p>
<h2 id="后续的规划">后续的规划</h2>
<p>随着 AI 的普及和渗透，获取知识、甚至获取技能都越来越轻而易举。坏的方面是，个人的知识和技能越来越贬值；乐观的方面是，个人可以利用的知识和技能也是越来越多，也越来越轻松。</p>
<p><img alt="Peter Steinberger github主页" loading="lazy" src="/images/2026-02-01/20260208-132545.jpg"></p>
<p>最近 OpenClaw 非常火，<a href="https://github.com/steipete">Peter Steinberger</a> 是其核心开发者。从其 GitHub 主页可以看到，在 Claude 爆火之前，他一直在做迭代各种各样的工具或者产品（具有完整定义功能的程序就算产品，不一定是像 WeChat/WhatsApp/TikTok 这样才算），OpenClaw的爆火不过是其多年程序迭代的一次厚积薄发。后面希望可以学习他这种方式，在做中学，在学中做，这也许是 AI 时代最快的进步方式。</p>
<p>后面将不再进行纯粹的单点知识分享，希望可以从打造一个真实可用的产品角度去分享打造的过程。这个产品只需要能提供完整可用的功能就行。</p>
<p>在这个知识和技能获取越来越便捷的时代，迭代速度也许才是制胜法宝。</p>
<hr>
<p>OK，以上就是一些个人浅显的、混乱的感想和 2026 年的 Flag，剩下的就交给时间和执行了，各位道友记得点赞追番一起加油吧！</p>
<p><img alt="请一键三连" loading="lazy" src="/images/2026-02-01/1770529335422.jpg"></p>
]]></content:encoded>
    </item>
    <item>
      <title>iOS音频捕获</title>
      <link>https://lyapple2008.github.io/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/</link>
      <pubDate>Sun, 25 Jan 2026 07:52:25 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇是iOS双语字幕软件的开发日志，目标是在iOS端实现，在观看视频时，实时对播放的内容进行识别和翻译，显示双语字幕，用于打破外语视频内容观看门槛。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<blockquote>
<p>这篇是iOS双语字幕软件的开发日志，目标是在iOS端实现，在观看视频时，实时对播放的内容进行识别和翻译，显示双语字幕，用于打破外语视频内容观看门槛。</p>
</blockquote>
<h3 id="模块流程">模块流程</h3>

<div class="mermaid">graph LR
    A[捕获系统播放音频] --&gt; B[语音识别ASR]
    B --&gt; C[语言翻译]
    B --&gt; D[双语字幕]
    C --&gt; D</div>
<h1 id="ios音频捕获与数据共享">iOS音频捕获与数据共享</h1>
<p>本文介绍iOS系统音频捕获的实现方案，使用Broadcast Upload Extension捕获系统播放的音频，并通过App Group与主应用共享数据。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#%e4%b8%80%e7%b3%bb%e7%bb%9f%e9%9f%b3%e9%a2%91%e6%8d%95%e8%8e%b7">一、系统音频捕获</a>
<ul>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#broadcast-upload-extension%e9%85%8d%e7%bd%ae">Broadcast Upload Extension配置</a></li>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#%e5%90%af%e5%8a%a8%e4%b8%8e%e5%85%b3%e9%97%ad">启动与关闭</a></li>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#%e9%9f%b3%e9%a2%91%e6%a0%bc%e5%bc%8f%e8%bd%ac%e6%8d%a2">音频格式转换</a></li>
</ul>
</li>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#%e4%ba%8cextension%e4%b8%8e%e4%b8%bb%e5%ba%94%e7%94%a8%e6%95%b0%e6%8d%ae%e5%85%b1%e4%ba%ab">二、Extension与主应用数据共享</a>
<ul>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#app-group%e9%85%8d%e7%bd%ae">App Group配置</a></li>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#%e6%95%b0%e6%8d%ae%e8%af%bb%e5%86%99%e5%ae%9e%e7%8e%b0">数据读写实现</a></li>
<li><a href="/posts/202601/2026-01-25-ios%E9%9F%B3%E9%A2%91%E6%8D%95%E8%8E%B7/#darwin%e9%80%9a%e7%9f%a5">Darwin通知</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="一系统音频捕获">一、系统音频捕获</h2>
<p>iOS系统出于安全和隐私考虑，<strong>不允许应用直接捕获系统音频</strong>（如视频播放、音乐等，使用通话模式的APP播放的声音捕获不到）。必须使用Broadcast Upload Extension，通过屏幕录制的形式获取音频数据。</p>
<h3 id="broadcast-upload-extension配置">Broadcast Upload Extension配置</h3>
<p>要让Extension收到ReplayKit的数据，必须同时满足：</p>
<ol>
<li>工程里有Broadcast Upload Extension target</li>
<li>主App用系统UI启动broadcast</li>
<li>Extension的Info.plist / Capabilities / 类继承全部正确</li>
</ol>
<p><strong>创建步骤：</strong></p>
<ol>
<li>
<p>在Xcode中新建Extension类型中选择Broadcast Upload Extension</p>
</li>
<li>
<p>配置Info.plist：</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;key&gt;</span>NSExtension<span class="nt">&lt;/key&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dict&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;key&gt;</span>NSExtensionPointIdentifier<span class="nt">&lt;/key&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;string&gt;</span>com.apple.broadcast-services-upload<span class="nt">&lt;/string&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;key&gt;</span>NSExtensionPrincipalClass<span class="nt">&lt;/key&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;string&gt;</span>$(PRODUCT_MODULE_NAME).SampleHandler<span class="nt">&lt;/string&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dict&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="3">
<li>主App配置UIBackgroundModes：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;key&gt;</span>UIBackgroundModes<span class="nt">&lt;/key&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;array&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;string&gt;</span>audio<span class="nt">&lt;/string&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/array&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>注意</strong>：未配置audio可能导致音频接收不到或屏幕锁定后Extension被暂停。</p>
<h3 id="启动与关闭">启动与关闭</h3>
<p>Broadcast upload extension不能在代码中直接启动，只能由系统UI触发。Extension只能自己调用<code>finishBroadcastWithError</code>关闭，主App只能&quot;间接控制&quot;关闭。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nv">picker</span> <span class="p">=</span> <span class="n">RPSystemBroadcastPickerView</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">44</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">picker</span><span class="p">.</span><span class="n">preferredExtension</span> <span class="p">=</span> <span class="s">&#34;com.xxx.broadcast&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">picker</span><span class="p">.</span><span class="n">showsMicrophoneButton</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">picker</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="音频格式转换">音频格式转换</h3>
<p>语音识别引擎接收的音频格式需要是16kHz单声道音频，因此这里需要先进行格式转换。这里需要注意是，并没有官方文档说ReplayKit回调的数据格式类型是怎样的，因此这里需要兼容各种格式。</p>
<p><strong>格式检测与提取：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kr">override</span> <span class="kd">func</span> <span class="nf">processSampleBuffer</span><span class="p">(</span><span class="kc">_</span> <span class="n">sampleBuffer</span><span class="p">:</span> <span class="n">CMSampleBuffer</span><span class="p">,</span> <span class="n">with</span> <span class="n">sampleBufferType</span><span class="p">:</span> <span class="n">RPSampleBufferType</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="k">case</span> <span class="p">.</span><span class="n">audioApp</span> <span class="p">=</span> <span class="n">sampleBufferType</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">formatDescription</span> <span class="p">=</span> <span class="n">CMSampleBufferGetFormatDescription</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nv">streamDesc</span> <span class="p">=</span> <span class="n">CMAudioFormatDescriptionGetStreamBasicDescription</span><span class="p">(</span><span class="n">formatDescription</span><span class="p">)?.</span><span class="n">pointee</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">inputSampleRate</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mSampleRate</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">channelCount</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">streamDesc</span><span class="p">.</span><span class="n">mChannelsPerFrame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">bitsPerChannel</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mBitsPerChannel</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">formatFlags</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mFormatFlags</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isFloat</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsFloat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isNonInterleaved</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsNonInterleaved</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isBigEndian</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsBigEndian</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 提取音频数据...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>完整的音频处理实现：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">let</span> <span class="nv">targetSampleRate</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">16000.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 处理音频样本buffer</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">func</span> <span class="nf">processAudioBuffer</span><span class="p">(</span><span class="kc">_</span> <span class="n">sampleBuffer</span><span class="p">:</span> <span class="n">CMSampleBuffer</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">formatDescription</span> <span class="p">=</span> <span class="n">CMSampleBufferGetFormatDescription</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nv">streamDesc</span> <span class="p">=</span> <span class="n">CMAudioFormatDescriptionGetStreamBasicDescription</span><span class="p">(</span><span class="n">formatDescription</span><span class="p">)?.</span><span class="n">pointee</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">inputSampleRate</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mSampleRate</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">channelCount</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">streamDesc</span><span class="p">.</span><span class="n">mChannelsPerFrame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">bitsPerChannel</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mBitsPerChannel</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">formatFlags</span> <span class="p">=</span> <span class="n">streamDesc</span><span class="p">.</span><span class="n">mFormatFlags</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isFloat</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsFloat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isNonInterleaved</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsNonInterleaved</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">isBigEndian</span> <span class="p">=</span> <span class="p">(</span><span class="n">formatFlags</span> <span class="o">&amp;</span> <span class="n">kAudioFormatFlagIsBigEndian</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取 AudioBufferList</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nv">audioBufferList</span> <span class="p">=</span> <span class="n">AudioBufferList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nv">blockBuffer</span><span class="p">:</span> <span class="n">CMBlockBuffer</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">status</span> <span class="p">=</span> <span class="n">CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">sampleBuffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">bufferListSizeNeededOut</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">bufferListOut</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">audioBufferList</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">bufferListSize</span><span class="p">:</span> <span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="n">AudioBufferList</span><span class="p">&gt;.</span><span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">blockBufferAllocator</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">blockBufferMemoryAllocator</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">flags</span><span class="p">:</span> <span class="n">kCMSampleBufferFlag_AudioBufferList_Assure16ByteAlignment</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">blockBufferOut</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">blockBuffer</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="n">status</span> <span class="p">==</span> <span class="n">noErr</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">audioBufferListPointer</span> <span class="p">=</span> <span class="n">UnsafeMutableAudioBufferListPointer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nb">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="n">AudioBufferList</span><span class="p">&gt;.</span><span class="n">allocate</span><span class="p">(</span><span class="n">capacity</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">audioBufferListPointer</span><span class="p">.</span><span class="n">unsafeMutablePointer</span><span class="p">.</span><span class="n">deallocate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">numBuffers</span> <span class="p">=</span> <span class="n">audioBufferListPointer</span><span class="p">.</span><span class="bp">count</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">frameCount</span> <span class="p">=</span> <span class="n">CMSampleBufferGetNumSamples</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nv">floatSamples</span><span class="p">:</span> <span class="p">[</span><span class="nb">Float</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理非交错格式</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">isNonInterleaved</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nv">channelData</span><span class="p">:</span> <span class="p">[[</span><span class="nb">Float</span><span class="p">]]</span> <span class="p">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">bufferIndex</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">numBuffers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">buffer</span> <span class="p">=</span> <span class="n">audioBufferListPointer</span><span class="p">[</span><span class="n">bufferIndex</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">guard</span> <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">mData</span> <span class="k">else</span> <span class="p">{</span> <span class="k">continue</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">dataByteSize</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">mDataByteSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="kd">var</span> <span class="nv">channelSamples</span><span class="p">:</span> <span class="p">[</span><span class="nb">Float</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">isFloat</span> <span class="o">&amp;&amp;</span> <span class="n">bitsPerChannel</span> <span class="p">==</span> <span class="mi">32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kd">let</span> <span class="nv">floatPtr</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">assumingMemoryBound</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="nb">Float</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="kd">let</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">dataByteSize</span> <span class="o">/</span> <span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="nb">Float</span><span class="p">&gt;.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="bp">count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kd">var</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">floatPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">isBigEndian</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">value</span> <span class="p">=</span> <span class="nb">Float</span><span class="p">(</span><span class="n">bitPattern</span><span class="p">:</span> <span class="n">value</span><span class="p">.</span><span class="n">bitPattern</span><span class="p">.</span><span class="n">bigEndian</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">channelSamples</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">bitsPerChannel</span> <span class="p">==</span> <span class="mi">16</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kd">let</span> <span class="nv">int16Ptr</span> <span class="p">=</span> <span class="n">data</span><span class="p">.</span><span class="n">assumingMemoryBound</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="nb">Int16</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="kd">let</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">dataByteSize</span> <span class="o">/</span> <span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="nb">Int16</span><span class="p">&gt;.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="bp">count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kd">var</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">int16Ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="n">isBigEndian</span> <span class="p">{</span> <span class="n">value</span> <span class="p">=</span> <span class="n">value</span><span class="p">.</span><span class="n">bigEndian</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">channelSamples</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">Float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">32768.0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">channelData</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">channelSamples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 混音为单声道</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="kd">let</span> <span class="nv">firstChannel</span> <span class="p">=</span> <span class="n">channelData</span><span class="p">.</span><span class="bp">first</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">channelData</span><span class="p">.</span><span class="bp">count</span> <span class="p">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">floatSamples</span> <span class="p">=</span> <span class="n">firstChannel</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">firstChannel</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kd">var</span> <span class="nv">sum</span><span class="p">:</span> <span class="nb">Float</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="n">ch</span> <span class="k">in</span> <span class="n">channelData</span> <span class="k">where</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ch</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">sum</span> <span class="o">+=</span> <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="n">floatSamples</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sum</span> <span class="o">/</span> <span class="nb">Float</span><span class="p">(</span><span class="n">channelData</span><span class="p">.</span><span class="bp">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 交错格式处理...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重采样到16kHz</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">inputSampleRate</span> <span class="o">!=</span> <span class="n">targetSampleRate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">floatSamples</span> <span class="p">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">floatSamples</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">inputSampleRate</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">targetSampleRate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sharedBuffer</span><span class="p">.</span><span class="n">writeAudioSamples</span><span class="p">(</span><span class="n">floatSamples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 使用AVAudioConverter重采样</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">func</span> <span class="nf">resample</span><span class="p">(</span><span class="kc">_</span> <span class="n">samples</span><span class="p">:</span> <span class="p">[</span><span class="nb">Float</span><span class="p">],</span> <span class="n">from</span> <span class="n">inputRate</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">to</span> <span class="n">outputRate</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Float</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="n">inputRate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">outputRate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inputRate</span> <span class="o">!=</span> <span class="n">outputRate</span><span class="p">,</span> <span class="o">!</span><span class="n">samples</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">samples</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">inputFormat</span> <span class="p">=</span> <span class="n">AVAudioFormat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">commonFormat</span><span class="p">:</span> <span class="p">.</span><span class="n">pcmFormatFloat32</span><span class="p">,</span> <span class="n">sampleRate</span><span class="p">:</span> <span class="n">inputRate</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">interleaved</span><span class="p">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">outputFormat</span> <span class="p">=</span> <span class="n">AVAudioFormat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">commonFormat</span><span class="p">:</span> <span class="p">.</span><span class="n">pcmFormatFloat32</span><span class="p">,</span> <span class="n">sampleRate</span><span class="p">:</span> <span class="n">outputRate</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">interleaved</span><span class="p">:</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">converter</span> <span class="p">=</span> <span class="n">AVAudioConverter</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">inputFormat</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">outputFormat</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">samples</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="kd">let</span> <span class="nv">inputBuffer</span> <span class="p">=</span> <span class="n">AVAudioPCMBuffer</span><span class="p">(</span><span class="n">pcmFormat</span><span class="p">:</span> <span class="n">inputFormat</span><span class="p">,</span> <span class="n">frameCapacity</span><span class="p">:</span> <span class="n">AVAudioFrameCount</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="bp">count</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nv">outputBuffer</span> <span class="p">=</span> <span class="n">AVAudioPCMBuffer</span><span class="p">(</span><span class="n">pcmFormat</span><span class="p">:</span> <span class="n">outputFormat</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">samples</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">inputBuffer</span><span class="p">.</span><span class="n">frameLength</span> <span class="p">=</span> <span class="n">AVAudioFrameCount</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">inputData</span> <span class="p">=</span> <span class="n">inputBuffer</span><span class="p">.</span><span class="n">floatChannelData</span><span class="p">!</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.&lt;</span><span class="n">samples</span><span class="p">.</span><span class="bp">count</span> <span class="p">{</span> <span class="n">inputData</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">ratio</span> <span class="p">=</span> <span class="n">outputRate</span> <span class="o">/</span> <span class="n">inputRate</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">outputFrameCount</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="nb">Double</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">outputBuffer</span><span class="p">.</span><span class="n">frameCapacity</span> <span class="p">=</span> <span class="n">AVAudioFrameCount</span><span class="p">(</span><span class="n">outputFrameCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nv">error</span><span class="p">:</span> <span class="n">NSError</span><span class="p">?</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">status</span> <span class="p">=</span> <span class="n">converter</span><span class="p">.</span><span class="n">convert</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">outputBuffer</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="p">&amp;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span> <span class="kc">_</span><span class="p">,</span> <span class="n">outStatus</span> <span class="k">in</span>
</span></span><span class="line"><span class="cl">        <span class="n">outStatus</span><span class="p">.</span><span class="n">pointee</span> <span class="p">=</span> <span class="p">.</span><span class="n">haveData</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">inputBuffer</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">guard</span> <span class="n">status</span> <span class="p">==</span> <span class="p">.</span><span class="n">haveData</span><span class="p">,</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="n">samples</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">outputData</span> <span class="p">=</span> <span class="n">outputBuffer</span><span class="p">.</span><span class="n">floatChannelData</span><span class="p">!</span>
</span></span><span class="line"><span class="cl">    <span class="kd">let</span> <span class="nv">outputLength</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">outputBuffer</span><span class="p">.</span><span class="n">frameLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">outputLength</span><span class="p">).</span><span class="bp">map</span> <span class="p">{</span> <span class="n">outputData</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nv">$0</span><span class="p">]</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>实现要点：</strong></p>
<ol>
<li><strong>内存安全</strong>：使用 <code>UnsafeMutableAudioBufferListPointer</code> 和 <code>defer</code> 确保内存正确释放</li>
<li><strong>多格式支持</strong>：支持 Float32、Int16、Int32 格式</li>
<li><strong>字节序处理</strong>：支持大端和小端字节序</li>
<li><strong>非交错格式</strong>：正确处理每个通道独立 buffer 的格式</li>
<li><strong>混音</strong>：立体声自动混音为单声道</li>
<li><strong>高质量重采样</strong>：使用系统 AVAudioConverter</li>
</ol>
<hr>
<h2 id="二extension与主应用数据共享">二、Extension与主应用数据共享</h2>
<p>Broadcast Extension与主应用运行在不同进程，涉及到进程间通信，这里选择使用实现比较简单的App Group共享容器进行数据交换。</p>
<h3 id="app-group配置">App Group配置</h3>
<p><strong>Entitlements配置：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;key&gt;</span>com.apple.security.application-groups<span class="nt">&lt;/key&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;array&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;string&gt;</span>group.com.xxx.shared<span class="nt">&lt;/string&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/array&gt;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>需要在Apple Developer Portal创建App Group，并在XCode中为两个target启用。</p>
<h3 id="数据读写实现">数据读写实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">AudioSharedBuffer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">appGroupId</span> <span class="p">=</span> <span class="s">&#34;group.com.xxx.shared&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">sharedContainerURL</span> <span class="p">=</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">containerURL</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">forSecurityApplicationGroupIdentifier</span><span class="p">:</span> <span class="kc">Self</span><span class="p">.</span><span class="n">appGroupId</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Extension写入处理后的音频</span>
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">writeAudioSamples</span><span class="p">(</span><span class="kc">_</span> <span class="n">samples</span><span class="p">:</span> <span class="p">[</span><span class="nb">Float</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">url</span> <span class="p">=</span> <span class="n">sharedContainerURL</span><span class="p">?.</span><span class="n">appendingPathComponent</span><span class="p">(</span><span class="s">&#34;audio.raw&#34;</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">samples</span><span class="p">.</span><span class="n">withUnsafeBufferPointer</span> <span class="p">{</span> <span class="n">Data</span><span class="p">(</span><span class="n">buffer</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">fileExists</span><span class="p">(</span><span class="n">atPath</span><span class="p">:</span> <span class="n">url</span><span class="p">.</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">handle</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">FileHandle</span><span class="p">(</span><span class="n">forWritingTo</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">handle</span><span class="p">?.</span><span class="n">seekToEndOfFile</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">handle</span><span class="p">?.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">handle</span><span class="p">?.</span><span class="n">closeFile</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span><span class="p">?</span> <span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">postDarwinNotification</span><span class="p">(</span><span class="s">&#34;com.xxx.newAudioData&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 主应用读取音频</span>
</span></span><span class="line"><span class="cl">    <span class="kd">func</span> <span class="nf">readAudioSamples</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Float</span><span class="p">]?</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">guard</span> <span class="kd">let</span> <span class="nv">url</span> <span class="p">=</span> <span class="n">sharedContainerURL</span><span class="p">?.</span><span class="n">appendingPathComponent</span><span class="p">(</span><span class="s">&#34;audio.raw&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">              <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">fileExists</span><span class="p">(</span><span class="n">atPath</span><span class="p">:</span> <span class="n">url</span><span class="p">.</span><span class="n">path</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">Data</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">?</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">removeItem</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">floatCount</span> <span class="p">=</span> <span class="n">data</span><span class="p">?.</span><span class="bp">count</span> <span class="p">??</span> <span class="mi">0</span> <span class="o">/</span> <span class="n">MemoryLayout</span><span class="p">&lt;</span><span class="nb">Float</span><span class="p">&gt;.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nv">samples</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Float</span><span class="p">](</span><span class="n">repeating</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">floatCount</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">?.</span><span class="n">copyBytes</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">samples</span><span class="p">.</span><span class="n">withUnsafeMutableBufferPointer</span> <span class="p">{</span> <span class="nv">$0</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">samples</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">postDarwinNotification</span><span class="p">(</span><span class="kc">_</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nv">center</span> <span class="p">=</span> <span class="n">CFNotificationCenterGetDarwinNotifyCenter</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">CFNotificationCenterPostNotification</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">CFNotificationName</span><span class="p">(</span><span class="n">name</span> <span class="k">as</span> <span class="n">CFString</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="darwin通知">Darwin通知</h3>
<p>Extension写入数据后发送Darwin通知，主应用监听后立即读取：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">startListening</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CFNotificationCenterAddObserver</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">CFNotificationCenterGetDarwinNotifyCenter</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="nb">Unmanaged</span><span class="p">.</span><span class="n">passUnretained</span><span class="p">(</span><span class="kc">self</span><span class="p">).</span><span class="n">toOpaque</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="kc">_</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="kc">_</span><span class="p">,</span> <span class="kc">_</span><span class="p">,</span> <span class="kc">_</span> <span class="k">in</span>
</span></span><span class="line"><span class="cl">            <span class="k">guard</span> <span class="kd">let</span> <span class="nv">observer</span> <span class="p">=</span> <span class="n">observer</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">selfPtr</span> <span class="p">=</span> <span class="nb">Unmanaged</span><span class="p">&lt;</span><span class="n">YourClass</span><span class="p">&gt;.</span><span class="n">fromOpaque</span><span class="p">(</span><span class="n">observer</span><span class="p">).</span><span class="n">takeUnretainedValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="kd">let</span> <span class="nv">samples</span> <span class="p">=</span> <span class="n">selfPtr</span><span class="p">.</span><span class="n">audioBuffer</span><span class="p">.</span><span class="n">readAudioSamples</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">selfPtr</span><span class="p">.</span><span class="n">onAudioReceived</span><span class="p">?(</span><span class="n">samples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;com.xxx.newAudioData&#34;</span> <span class="k">as</span> <span class="n">CFString</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kc">nil</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">deliverImmediately</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<hr>
<h2 id="samplehandler完整示例">SampleHandler完整示例</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">SampleHandler</span><span class="p">:</span> <span class="n">RPBroadcastSampleHandler</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">sharedBuffer</span> <span class="p">=</span> <span class="n">AudioSharedBuffer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">let</span> <span class="nv">targetSampleRate</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">16000.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">broadcastStarted</span><span class="p">(</span><span class="n">withSetupInfo</span> <span class="n">setupInfo</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span> <span class="p">:</span> <span class="n">NSObject</span><span class="p">]?)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sharedBuffer</span><span class="p">.</span><span class="n">clearAudioData</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">broadcastPaused</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">broadcastResumed</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">broadcastFinished</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">processSampleBuffer</span><span class="p">(</span><span class="kc">_</span> <span class="n">sampleBuffer</span><span class="p">:</span> <span class="n">CMSampleBuffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">with</span> <span class="n">sampleBufferType</span><span class="p">:</span> <span class="n">RPSampleBufferType</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="n">sampleBufferType</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="p">.</span><span class="n">audioApp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 处理应用音频（系统播放的音频）</span>
</span></span><span class="line"><span class="cl">            <span class="kd">let</span> <span class="nv">samples</span> <span class="p">=</span> <span class="n">convertTo16kMono</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">sharedBuffer</span><span class="p">.</span><span class="n">writeAudioSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="p">.</span><span class="n">audioMic</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 忽略麦克风音频</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="p">.</span><span class="n">video</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 忽略视频</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>使用ORT进行语音降噪模型推理</title>
      <link>https://lyapple2008.github.io/posts/202511/2025-11-03-%E4%BD%BF%E7%94%A8ort%E8%BF%9B%E8%A1%8C%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA%E6%8E%A8%E7%90%86/</link>
      <pubDate>Mon, 03 Nov 2025 19:39:53 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202511/2025-11-03-%E4%BD%BF%E7%94%A8ort%E8%BF%9B%E8%A1%8C%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA%E6%8E%A8%E7%90%86/</guid>
      <description>&lt;p&gt;在深度学习语音降噪模型的部署过程中，选择合适的推理引擎至关重要。ONNX Runtime（ORT）作为微软开源的跨平台推理引擎，在性能、兼容性和易用性方面表现出色，已成为许多生产环境的首选。本文将介绍为什么选择ORT，ORT的核心概念和使用流程，以及在使用ORT进行语音降噪推理时需要注意的关键事项，特别是针对时序模型（如GRU/LSTM）的隐状态管理。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>在深度学习语音降噪模型的部署过程中，选择合适的推理引擎至关重要。ONNX Runtime（ORT）作为微软开源的跨平台推理引擎，在性能、兼容性和易用性方面表现出色，已成为许多生产环境的首选。本文将介绍为什么选择ORT，ORT的核心概念和使用流程，以及在使用ORT进行语音降噪推理时需要注意的关键事项，特别是针对时序模型（如GRU/LSTM）的隐状态管理。</p>
<h2 id="一为什么选择ort">一、为什么选择ORT？</h2>
<h3 id="11-跨平台支持">1.1 跨平台支持</h3>
<p>ORT提供了广泛的平台支持，包括：</p>
<ul>
<li><strong>CPU推理</strong>：支持x86、ARM等架构，可在Windows、Linux、macOS、Android、iOS等系统运行</li>
<li><strong>GPU加速</strong>：支持CUDA（NVIDIA GPU）、DirectML（Windows）、TensorRT等</li>
<li><strong>专用硬件</strong>：支持CoreML（Apple Silicon）、OpenVINO（Intel）、QNN（Qualcomm）等</li>
</ul>
<p>这种跨平台特性使得同一套代码可以在不同设备上运行，大大降低了部署成本。</p>
<h3 id="12-性能优化">1.2 性能优化</h3>
<p>ORT在性能方面做了大量优化：</p>
<ul>
<li><strong>图优化</strong>：自动进行算子融合、常量折叠、死代码消除等优化</li>
<li><strong>执行提供者（Execution Provider）</strong>：针对不同硬件提供专门的优化实现</li>
<li><strong>动态形状支持</strong>：支持动态batch size和序列长度，适合实时推理场景</li>
</ul>
<h3 id="13-模型格式标准化">1.3 模型格式标准化</h3>
<p>ORT基于ONNX（Open Neural Network Exchange）格式，这是业界标准的模型交换格式：</p>
<ul>
<li><strong>框架无关</strong>：可以从PyTorch、TensorFlow、Keras等框架导出ONNX模型</li>
<li><strong>版本兼容</strong>：ONNX规范持续演进，ORT保持向后兼容</li>
<li><strong>工具生态</strong>：丰富的模型转换和优化工具</li>
</ul>
<h3 id="14-易于集成">1.4 易于集成</h3>
<p>ORT提供了多种语言绑定：</p>
<ul>
<li><strong>C++ API</strong>：适合高性能场景和嵌入式设备</li>
<li><strong>Python API</strong>：便于快速原型开发和调试</li>
<li><strong>C#、Java、JavaScript</strong>：支持多种应用场景</li>
</ul>
<h3 id="15-活跃的社区支持">1.5 活跃的社区支持</h3>
<p>作为微软开源项目，ORT拥有活跃的社区和持续的更新，bug修复和新功能迭代速度快。</p>
<h2 id="二ort基本概念与推理流程">二、ORT基本概念与推理流程</h2>
<h3 id="21-核心概念">2.1 核心概念</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">   ┌───────────────────────────────┐
</span></span><span class="line"><span class="cl">   │ OrtEnv （运行时环境）         │
</span></span><span class="line"><span class="cl">   │ └─ 管理全局资源、线程池等     │
</span></span><span class="line"><span class="cl">   └──────────────┬────────────────┘
</span></span><span class="line"><span class="cl">                  │
</span></span><span class="line"><span class="cl">   ┌──────────────┴────────────────┐
</span></span><span class="line"><span class="cl">   │ OrtSession （推理会话）        │
</span></span><span class="line"><span class="cl">   │ └─ 持有已加载的 ONNX 模型      │
</span></span><span class="line"><span class="cl">   └──────────────┬────────────────┘
</span></span><span class="line"><span class="cl">                  │
</span></span><span class="line"><span class="cl">   ┌──────────────┴────────────────────────┐
</span></span><span class="line"><span class="cl">   │ OrtRun（一次推理调用）                │
</span></span><span class="line"><span class="cl">   │ ├─ 输入 OrtValue (Tensor 等)           │
</span></span><span class="line"><span class="cl">   │ ├─ 输出 OrtValue                      │
</span></span><span class="line"><span class="cl">   │ └─ 在 Env/Session 的线程池中执行      │
</span></span><span class="line"><span class="cl">   └────────────────────────────────────────┘</span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="ortenv运行时环境">OrtEnv（运行时环境）</h4>
<p><code>OrtEnv</code>是ORT的全局运行时环境，负责管理线程池、日志等全局资源。通常一个进程只需要创建一个<code>OrtEnv</code>实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;onnxruntime_c_api.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建运行时环境
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OrtEnv</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">OrtStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="nf">OrtCreateEnv</span><span class="p">(</span><span class="n">ORT_LOGGING_LEVEL_WARNING</span><span class="p">,</span> <span class="s">&#34;ORT&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nf">OrtGetErrorMessage</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">OrtReleaseStatus</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="ortsession推理会话">OrtSession（推理会话）</h4>
<p><code>OrtSession</code>负责加载ONNX模型并执行推理。创建会话需要先创建会话选项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;onnxruntime_c_api.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 创建会话选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OrtSessionOptions</span><span class="o">*</span> <span class="n">session_options</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtCreateSessionOptions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session_options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 创建推理会话
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OrtSession</span><span class="o">*</span> <span class="n">session</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">model_path</span> <span class="o">=</span> <span class="s">&#34;denoise_model.onnx&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">status</span> <span class="o">=</span> <span class="nf">OrtCreateSession</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">session_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 错误处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nf">OrtGetErrorMessage</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">OrtReleaseStatus</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 释放资源（使用完毕后）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtReleaseSessionOptions</span><span class="p">(</span><span class="n">session_options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtReleaseSession</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtReleaseEnv</span><span class="p">(</span><span class="n">env</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="execution-provider-ep">Execution Provider (EP)</h4>
<p>执行提供者决定了模型在哪个硬件上运行。在C API中，通过<code>OrtSessionOptionsAppendExecutionProvider</code>添加EP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// CPU执行（默认，无需显式添加）
</span></span></span><span class="line"><span class="cl"><span class="c1">// 直接创建会话即可使用CPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// CUDA执行（需要NVIDIA GPU）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSessionOptionsAppendExecutionProvider_CUDA</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// TensorRT执行（需要NVIDIA GPU和TensorRT）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OrtTensorRTProviderOptions</span> <span class="n">trt_options</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtSessionOptionsAppendExecutionProvider_TensorRT</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trt_options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CoreML执行（macOS/iOS）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSessionOptionsAppendExecutionProvider_CoreML</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 创建会话（会按顺序尝试EP，失败则回退到下一个）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtCreateSession</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">session_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="inputoutput">Input/Output</h4>
<p>模型的输入输出通过<code>OrtValue</code>传递，需要手动创建和管理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 1. 获取输入输出信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">size_t</span> <span class="n">num_input_nodes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">OrtStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="nf">OrtSessionGetInputCount</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_input_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">input_name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">OrtTypeInfo</span><span class="o">*</span> <span class="n">input_type_info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtSessionGetInputName</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtSessionGetInputTypeInfo</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_type_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 准备输入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">input_data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* audio_features数据 */</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int64_t</span> <span class="n">input_shape</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">480</span><span class="p">};</span>  <span class="c1">// batch_size, feature_dim
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">size_t</span> <span class="n">input_tensor_size</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">OrtValue</span><span class="o">*</span> <span class="n">input_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">OrtMemoryInfo</span><span class="o">*</span> <span class="n">memory_info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtCreateCpuMemoryInfo</span><span class="p">(</span><span class="n">OrtArenaAllocator</span><span class="p">,</span> <span class="n">OrtMemTypeDefault</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtCreateTensorWithDataAsOrtValue</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_info</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_data</span><span class="p">,</span> <span class="n">input_tensor_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">input_tensor</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 执行推理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">input_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">input_name</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">output_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;output&#34;</span><span class="p">};</span>  <span class="c1">// 根据模型实际输出名称
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">OrtValue</span><span class="o">*</span> <span class="n">output_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">status</span> <span class="o">=</span> <span class="nf">OrtRun</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_names</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_tensor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_names</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 4. 获取输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span><span class="o">*</span> <span class="n">output_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtGetTensorMutableData</span><span class="p">(</span><span class="n">output_tensor</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">output_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用output_data...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 5. 释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtReleaseValue</span><span class="p">(</span><span class="n">output_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtReleaseValue</span><span class="p">(</span><span class="n">input_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="22-性能优化选项">2.2 性能优化选项</h3>
<p>ORT提供了多种性能优化选项，在C API中通过<code>OrtSessionOptions</code>进行配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">OrtSessionOptions</span><span class="o">*</span> <span class="n">session_options</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">OrtCreateSessionOptions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session_options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 图优化级别
</span></span></span><span class="line"><span class="cl"><span class="c1">// ORT_DISABLE_ALL, ORT_ENABLE_BASIC, ORT_ENABLE_EXTENDED, ORT_ENABLE_ALL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSetSessionGraphOptimizationLevel</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="n">ORT_ENABLE_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程数设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSetIntraOpNumThreads</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>  <span class="c1">// 算子内部并行线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSetInterOpNumThreads</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 算子间并行线程数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 内存模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtEnableMemPattern</span><span class="p">(</span><span class="n">session_options</span><span class="p">);</span>  <span class="c1">// 启用内存模式优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtEnableCpuMemArena</span><span class="p">(</span><span class="n">session_options</span><span class="p">);</span> <span class="c1">// 启用CPU内存池
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 执行模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtSetSessionExecutionMode</span><span class="p">(</span><span class="n">session_options</span><span class="p">,</span> <span class="n">ORT_SEQUENTIAL</span><span class="p">);</span>  <span class="c1">// 顺序执行
</span></span></span><span class="line"><span class="cl"><span class="c1">// OrtSetSessionExecutionMode(session_options, ORT_PARALLEL);  // 并行执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 优化配置文件（可选，用于更精细的控制）
</span></span></span><span class="line"><span class="cl"><span class="c1">// OrtSetOptimizedModelFilePath(session_options, &#34;optimized_model.onnx&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 创建会话时应用这些选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtCreateSession</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">session_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用完毕后释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">OrtReleaseSessionOptions</span><span class="p">(</span><span class="n">session_options</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="三语音降噪推理的特殊注意事项">三、语音降噪推理的特殊注意事项</h2>
<p>语音降噪模型通常使用时序建模网络（如GRU、LSTM），这些网络具有隐状态（hidden state），在实时推理时需要特别注意状态管理。</p>
<h3 id="31-为什么ort不保存隐状态">3.1 为什么ORT不保存隐状态？</h3>
<p>ORT（ONNX Runtime）采用**无状态（stateless）**的设计理念，即每次推理调用都是独立的，ORT不会在内部保存任何状态信息。这种设计有以下几个重要原因：</p>
<h4 id="311-设计理念无状态推理">3.1.1 设计理念：无状态推理</h4>
<p>ORT的核心设计原则是每次<code>OrtRun</code>调用都是完全独立的，不依赖之前的调用结果。这种设计带来以下优势：</p>
<ol>
<li><strong>线程安全</strong>：多个线程可以同时使用同一个<code>OrtSession</code>进行推理，而不会因为共享状态导致竞争条件</li>
<li><strong>可重现性</strong>：相同的输入总是产生相同的输出，不受历史状态影响</li>
<li><strong>灵活性</strong>：可以灵活控制何时重置状态、何时复用状态，适应不同的应用场景</li>
</ol>
<h4 id="312-状态管理的责任归属">3.1.2 状态管理的责任归属</h4>
<p>在ORT的设计中，<strong>状态管理是应用层的责任</strong>，而不是推理引擎的责任。这样做的好处是：</p>
<ul>
<li><strong>应用层控制</strong>：应用可以根据业务需求决定何时重置状态、如何管理多个流的状态</li>
<li><strong>内存管理</strong>：应用可以精确控制状态的内存分配和释放时机</li>
<li><strong>多实例支持</strong>：同一个模型可以同时处理多个独立的音频流，每个流维护自己的状态</li>
</ul>
<h4 id="313-与训练框架的差异">3.1.3 与训练框架的差异</h4>
<p>在训练框架（如PyTorch、TensorFlow）中，RNN/LSTM层通常会维护隐状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># PyTorch训练时的行为</span>
</span></span><span class="line"><span class="cl"><span class="n">lstm</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="n">hidden</span><span class="p">,</span> <span class="n">cell</span><span class="p">))</span>  <span class="c1"># 状态在层内部管理</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>但在ONNX导出和ORT推理时，隐状态被<strong>显式化</strong>为模型的输入和输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// ONNX模型结构
</span></span></span><span class="line"><span class="cl"><span class="c1">// 输入: [audio_features, hidden_state, cell_state]  // 显式输入
</span></span></span><span class="line"><span class="cl"><span class="c1">// 输出: [denoised_features, new_hidden_state, new_cell_state]  // 显式输出
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>这种显式化的设计使得：</p>
<ul>
<li>状态在模型外部可见和可控</li>
<li>可以跨框架、跨平台保持一致的行为</li>
<li>便于调试和优化</li>
</ul>
<h4 id="314-实际影响">3.1.4 实际影响</h4>
<p>对于语音降噪等时序应用，ORT不保存隐状态意味着：</p>
<ol>
<li><strong>必须手动传递状态</strong>：每次推理时，需要将上一次的输出状态作为下一次的输入</li>
<li><strong>状态持久化由应用负责</strong>：如果需要保存状态（如断点续传），需要应用层实现</li>
<li><strong>多流处理需要独立状态</strong>：处理多个音频流时，需要为每个流维护独立的状态变量</li>
</ol>
<p>这种设计虽然增加了应用层的复杂度，但提供了更大的灵活性和控制力，特别适合生产环境中的复杂场景。</p>
<h3 id="32-实战使用ort进行rnnoise降噪推理">3.2 实战使用ORT进行Rnnoise降噪推理</h3>
<p>RNNoise是一个基于深度学习的实时语音降噪模型，使用了三个GRU层（VAD GRU、Noise GRU、Denoise GRU）进行时序建模。在使用ORT进行推理时，需要特别注意这三个GRU层的隐状态管理。</p>
<h4 id="321-转换成onnx模型时导出gru隐状态输入输出端口">3.2.1 转换成ONNX模型时导出GRU隐状态输入输出端口</h4>
<p>RNNoise的Keras训练模型通常只接受特征输入，GRU的隐状态在内部管理。但在导出ONNX模型用于ORT推理时，需要将隐状态显式化为模型的输入和输出端口，这样才能在应用层控制状态传递。</p>
<p><strong>关键步骤：</strong></p>
<ol>
<li><strong>重建模型结构</strong>：创建一个新的推理模型，为每个GRU层添加<code>initial_state</code>输入和<code>return_state=True</code>输出</li>
<li><strong>复制权重</strong>：从训练模型复制所有层的权重到新模型</li>
<li><strong>定义输入输出</strong>：新模型有4个输入（features + 3个GRU状态）和5个输出（denoise_output + vad_output + 3个GRU状态）</li>
</ol>
<p>下图中，左侧为没有导出隐状态的onnx模型可视化图，可以看到gru的隐状态每次都是被重置的；右侧为导出了隐状态的onnx模型可视化图，可以看到gru节点对应了一个gru state输入端口和一个gru state的输出端口。</p>
<p><img alt="rnnoise-onnx-导出隐状态" loading="lazy" src="/images/2025-11-03/rnnoise-onnx-%E5%AF%BC%E5%87%BA%E9%9A%90%E7%8A%B6%E6%80%81.jpg"></p>
<p>以下是完整的转换代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">keras.backend</span> <span class="k">as</span> <span class="nn">K</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.constraints</span> <span class="kn">import</span> <span class="n">Constraint</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">GRU</span><span class="p">,</span> <span class="n">concatenate</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">my_crossentropy</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">binary_crossentropy</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">y_true</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mymask</span><span class="p">(</span><span class="n">y_true</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_true</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">msse</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mymask</span><span class="p">(</span><span class="n">y_true</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_true</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mycost</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">mymask</span><span class="p">(</span><span class="n">y_true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="mi">10</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_true</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">            <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">binary_crossentropy</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">y_true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">my_accuracy</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">WeightClip</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Accept **kwargs to be compatible with Keras deserialization that may pass &#39;name&#39; etc.</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># kwargs may include &#39;name&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">K</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">CUSTOM_OBJECTS</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;my_crossentropy&#39;</span><span class="p">:</span> <span class="n">my_crossentropy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;mymask&#39;</span><span class="p">:</span> <span class="n">mymask</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;msse&#39;</span><span class="p">:</span> <span class="n">msse</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;mycost&#39;</span><span class="p">:</span> <span class="n">mycost</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;my_accuracy&#39;</span><span class="p">:</span> <span class="n">my_accuracy</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;WeightClip&#39;</span><span class="p">:</span> <span class="n">WeightClip</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">rebuild_model_with_states</span><span class="p">(</span><span class="n">training_model</span><span class="p">:</span> <span class="n">Model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    自动重建模型，添加GRU隐状态输入/输出端口。
</span></span></span><span class="line"><span class="cl"><span class="s2">    如果模型已经有GRU状态端口，直接返回原模型。
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查是否已有GRU状态端口</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_model</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_model</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;  Model already has GRU state ports, skipping rebuild&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">training_model</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;  Rebuilding model with GRU state inputs/outputs...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># 新的推理输入（带状态）</span>
</span></span><span class="line"><span class="cl">    <span class="n">features_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;features&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_state_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">24</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;vad_gru_state&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_state_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">48</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;noise_gru_state&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_state_in</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">96</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;denoise_gru_state&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 复制训练模型的层配置并加载权重</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1) input_dense</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_dense_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;input_dense&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_dense</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;input_dense_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">input_dense_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">bias_constraint</span><span class="o">=</span><span class="n">input_dense_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">tmp_export</span> <span class="o">=</span> <span class="n">input_dense</span><span class="p">(</span><span class="n">features_in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">input_dense</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">input_dense_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 2) vad_gru (return_sequences+return_state)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_gru_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;vad_gru&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_gru_exp</span> <span class="o">=</span> <span class="n">GRU</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="n">recurrent_activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">return_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;vad_gru_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">kernel_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">recurrent_regularizer</span><span class="o">=</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">recurrent_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">recurrent_constraint</span><span class="o">=</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">recurrent_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">bias_constraint</span><span class="o">=</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_seq</span><span class="p">,</span> <span class="n">vad_state_out</span> <span class="o">=</span> <span class="n">vad_gru_exp</span><span class="p">(</span><span class="n">tmp_export</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">vad_state_in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_gru_exp</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">vad_gru_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 3) vad_output</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_output_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;vad_output&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_output_exp_layer</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;vad_output_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">vad_output_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">bias_constraint</span><span class="o">=</span><span class="n">vad_output_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_output_exp</span> <span class="o">=</span> <span class="n">vad_output_exp_layer</span><span class="p">(</span><span class="n">vad_seq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">vad_output_exp_layer</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">vad_output_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 4) noise_gru 输入：concat([tmp_export, vad_seq, features_in])</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_in</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">tmp_export</span><span class="p">,</span> <span class="n">vad_seq</span><span class="p">,</span> <span class="n">features_in</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;noise_concat_export&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_gru_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;noise_gru&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_gru_exp</span> <span class="o">=</span> <span class="n">GRU</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">recurrent_activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">return_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;noise_gru_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">kernel_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">recurrent_regularizer</span><span class="o">=</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">recurrent_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">recurrent_constraint</span><span class="o">=</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">recurrent_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">bias_constraint</span><span class="o">=</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_seq</span><span class="p">,</span> <span class="n">noise_state_out</span> <span class="o">=</span> <span class="n">noise_gru_exp</span><span class="p">(</span><span class="n">noise_in</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">noise_state_in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">noise_gru_exp</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">noise_gru_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 5) denoise_gru 输入：concat([vad_seq, noise_seq, features_in])</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_in</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">vad_seq</span><span class="p">,</span> <span class="n">noise_seq</span><span class="p">,</span> <span class="n">features_in</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;denoise_concat_export&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_gru_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;denoise_gru&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_gru_exp</span> <span class="o">=</span> <span class="n">GRU</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="n">recurrent_activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">return_sequences</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;denoise_gru_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">kernel_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">recurrent_regularizer</span><span class="o">=</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">recurrent_regularizer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">recurrent_constraint</span><span class="o">=</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">recurrent_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">bias_constraint</span><span class="o">=</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_seq</span><span class="p">,</span> <span class="n">denoise_state_out</span> <span class="o">=</span> <span class="n">denoise_gru_exp</span><span class="p">(</span><span class="n">denoise_in</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">denoise_state_in</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_gru_exp</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">denoise_gru_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 6) denoise_output</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_output_src</span> <span class="o">=</span> <span class="n">training_model</span><span class="o">.</span><span class="n">get_layer</span><span class="p">(</span><span class="s1">&#39;denoise_output&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_output_exp_layer</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;denoise_output_export&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">kernel_constraint</span><span class="o">=</span><span class="n">denoise_output_src</span><span class="o">.</span><span class="n">kernel_constraint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">bias_constraint</span><span class="o">=</span><span class="n">denoise_output_src</span><span class="o">.</span><span class="n">bias_constraint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_output_exp</span> <span class="o">=</span> <span class="n">denoise_output_exp_layer</span><span class="p">(</span><span class="n">denoise_seq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">denoise_output_exp_layer</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">denoise_output_src</span><span class="o">.</span><span class="n">get_weights</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">export_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">features_in</span><span class="p">,</span> <span class="n">vad_state_in</span><span class="p">,</span> <span class="n">noise_state_in</span><span class="p">,</span> <span class="n">denoise_state_in</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">denoise_output_exp</span><span class="p">,</span> <span class="n">vad_output_exp</span><span class="p">,</span> <span class="n">vad_state_out</span><span class="p">,</span> <span class="n">noise_state_out</span><span class="p">,</span> <span class="n">denoise_state_out</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rnnoise_export_with_states&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;  ✓ Model rebuilt successfully with GRU state ports&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">export_model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">hdf5_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">onnx_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">opset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">auto_rebuild</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">hdf5_path</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;HDF5 model not found: </span><span class="si">{</span><span class="n">hdf5_path</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Loading Keras model from: </span><span class="si">{</span><span class="n">hdf5_path</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Load with custom objects registered for deserialization</span>
</span></span><span class="line"><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">hdf5_path</span><span class="p">,</span> <span class="n">custom_objects</span><span class="o">=</span><span class="n">CUSTOM_OBJECTS</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Auto-rebuild model with GRU states if needed</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">auto_rebuild</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">=== Auto-Rebuild Mode ===&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;  Checking if model needs GRU state ports...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">model</span> <span class="o">=</span> <span class="n">rebuild_model_with_states</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;  Model ready for conversion with GRU state ports</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the model has GRU state inputs/outputs</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_outputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Model has </span><span class="si">{</span><span class="n">num_inputs</span><span class="si">}</span><span class="s2"> input(s) and </span><span class="si">{</span><span class="n">num_outputs</span><span class="si">}</span><span class="s2"> output(s)&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Print input information</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;  Input </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">inp</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, shape: </span><span class="si">{</span><span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Print output information</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;  Output </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, shape: </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if this is a model with GRU states (4 inputs and 5 outputs)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">num_inputs</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">num_outputs</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Detected model with GRU state inputs/outputs&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Build input signature for model with efficient state management</span>
</span></span><span class="line"><span class="cl">        <span class="n">input_specs</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">inp_name</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">inp_shape</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1"># Handle different input shapes</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># features: (None, None, 42)</span>
</span></span><span class="line"><span class="cl">                <span class="n">spec</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inp_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">inp_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># GRU states: (None, hidden_size)</span>
</span></span><span class="line"><span class="cl">                <span class="n">spec</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">inp_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">inp_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Fallback: use dynamic shape</span>
</span></span><span class="line"><span class="cl">                <span class="n">spec</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_shape</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">inp_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">input_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Converting to ONNX (opset </span><span class="si">{</span><span class="n">opset</span><span class="si">}</span><span class="s2">) with GRU state inputs/outputs...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert with all input signatures</span>
</span></span><span class="line"><span class="cl">        <span class="n">tf2onnx</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_keras</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">input_signature</span><span class="o">=</span><span class="n">input_specs</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">opset</span><span class="o">=</span><span class="n">opset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">elif</span> <span class="n">num_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Detected standard model without GRU state ports&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Use a dynamic input signature (None, None, 42) to preserve time dimension flexibility</span>
</span></span><span class="line"><span class="cl">        <span class="n">input_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">input_name</span><span class="p">),)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Converting to ONNX (opset </span><span class="si">{</span><span class="n">opset</span><span class="si">}</span><span class="s2">)...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Convert directly from the Keras model</span>
</span></span><span class="line"><span class="cl">        <span class="n">tf2onnx</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_keras</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">input_signature</span><span class="o">=</span><span class="n">spec</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">opset</span><span class="o">=</span><span class="n">opset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Generic conversion for models with multiple inputs but unknown structure</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Converting to ONNX (opset </span><span class="si">{</span><span class="n">opset</span><span class="si">}</span><span class="s2">) with </span><span class="si">{</span><span class="n">num_inputs</span><span class="si">}</span><span class="s2"> inputs...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">input_specs</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">inp_name</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">inp_shape</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Use dynamic shapes for flexibility</span>
</span></span><span class="line"><span class="cl">            <span class="n">spec</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp_shape</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">inp_name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">input_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tf2onnx</span><span class="o">.</span><span class="n">convert</span><span class="o">.</span><span class="n">from_keras</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">input_signature</span><span class="o">=</span><span class="n">input_specs</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="n">onnx_path</span><span class="p">,</span> <span class="n">opset</span><span class="o">=</span><span class="n">opset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Saved ONNX model to: </span><span class="si">{</span><span class="n">onnx_path</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Convert Keras HDF5 model to ONNX for RNNoise.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--input&#39;</span><span class="p">,</span> <span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Path to Keras HDF5 model file&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--output&#39;</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Path to output ONNX file&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--opset&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;ONNX opset version (default: 13)&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--auto-rebuild&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Automatically rebuild model with GRU state ports if missing&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">input_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_path</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">output</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">base</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">input_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">output_path</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="s1">&#39;.onnx&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">output_path</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">convert</span><span class="p">(</span><span class="n">input_path</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">opset</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">opset</span><span class="p">,</span> <span class="n">auto_rebuild</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">auto_rebuild</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">main</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="322-推理时对隐状态进行管理">3.2.2 推理时对隐状态进行管理</h4>
<p>前面导出onnx模型时，已经为每个GRU节点导出了隐状态的输入和输出端口，因此在每一次帧的时候，只需要将上一次推理保存的隐状态信息输入到对应的隐状态输入端口，同时在推理后对GRU节点的隐状态输出端口进行保存，就可以实现流式推理GRU保留历史信息了。</p>
<p>以下是部分核心函数实现，只需要将其嵌入到原rnnoise降噪代码中就可以实现ort推理了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Initialize ONNX model
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">initialize_onnx_model</span><span class="p">(</span><span class="n">RNNoiseContext</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">model_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Get ONNX Runtime API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">OrtApiBase</span><span class="o">*</span> <span class="n">api_base</span> <span class="o">=</span> <span class="nf">OrtGetApiBase</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">api_base</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting ONNX Runtime API base</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span> <span class="o">=</span> <span class="n">api_base</span><span class="o">-&gt;</span><span class="nf">GetApi</span><span class="p">(</span><span class="n">ORT_API_VERSION</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting ONNX Runtime API</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize ONNX Runtime environment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">OrtStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateEnv</span><span class="p">(</span><span class="n">ORT_LOGGING_LEVEL_WARNING</span><span class="p">,</span> <span class="s">&#34;RNNoiseONNX&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">env</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating ONNX Runtime environment</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Create session options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateSessionOptions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating session options</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Set session options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SetIntraOpNumThreads</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_options</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error setting intra-op threads</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SetSessionGraphOptimizationLevel</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_options</span><span class="p">,</span> <span class="n">ORT_ENABLE_EXTENDED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error setting optimization level</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Create session
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateSession</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">env</span><span class="p">,</span> <span class="n">model_path</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating ONNX session</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Get allocator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetAllocatorWithDefaultOptions</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting allocator</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Get input/output names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">num_input_nodes</span><span class="p">,</span> <span class="n">num_output_nodes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputCount</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_input_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting input count</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputCount</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_output_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting output count</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ONNX Model Info:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Input nodes: %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_input_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Output nodes: %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_output_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Detect model type: 4 inputs + 5 outputs = model with GRU states
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">has_gru_states</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_input_nodes</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">num_output_nodes</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">has_gru_states</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Model type: WITH GRU state inputs/outputs</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Get all input names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting features input name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_vad_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting VAD state input name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_noise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting noise state input name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_denoise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting denoise state input name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Get all output names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting denoise output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting VAD output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting VAD state output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_noise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting noise state output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting denoise state output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Inputs:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [0] %s (features)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [1] %s (VAD GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_vad_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [2] %s (noise GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_noise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [3] %s (denoise GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_denoise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Outputs:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [0] %s (denoise)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [1] %s (VAD)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [2] %s (VAD GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [3] %s (noise GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_noise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;    [4] %s (denoise GRU state)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Model type: Standard (without GRU state ports)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Get input name (standard model)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetInputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting input name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// Get output names (standard model)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting denoise output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">SessionGetOutputName</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting VAD output name</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Input: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Output denoise: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;  Output VAD: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Allocate buffers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">FRAME_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">FRAME_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_buffer</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_buffer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error: Memory allocation failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize RNNoise state for feature extraction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_state</span> <span class="o">=</span> <span class="nf">rnnoise_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error: Failed to create RNNoise state</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">rnnoise_init</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_state</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize biquad filter memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mem_hp_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mem_hp_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize processing buffers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">X</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">P</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Ex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Ex</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Ep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Ep</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Exp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">Exp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lastg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">lastg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">synthesis_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">synthesis_mem</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize frame count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">frame_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize GRU states if model supports it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">initialize_gru_states</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ONNX model loaded successfully: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">model_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Initialize GRU states
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">initialize_gru_states</span><span class="p">(</span><span class="n">RNNoiseContext</span><span class="o">*</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">vad_gru_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">vad_gru_state</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">noise_gru_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">noise_gru_state</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_gru_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_gru_state</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gru_states_initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ONNX inference with external state management
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">onnx_inference_with_states</span><span class="p">(</span><span class="n">RNNoiseContext</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">features</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">gains</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">vad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Prepare separate input tensors for features and GRU states
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">features_data</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">vad_state_data</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">noise_state_data</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">denoise_state_data</span><span class="p">[</span><span class="mi">96</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Copy features
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memcpy</span><span class="p">(</span><span class="n">features_data</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="mi">42</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Copy GRU states (use saved states for next frame)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memcpy</span><span class="p">(</span><span class="n">vad_state_data</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">vad_gru_state</span><span class="p">,</span> <span class="mi">24</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">noise_state_data</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">noise_gru_state</span><span class="p">,</span> <span class="mi">48</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">denoise_state_data</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_gru_state</span><span class="p">,</span> <span class="mi">96</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Create input tensors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">features_shape</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">vad_state_shape</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">24</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">noise_state_shape</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">48</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">denoise_state_shape</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">96</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">OrtMemoryInfo</span><span class="o">*</span> <span class="n">memory_info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateCpuMemoryInfo</span><span class="p">(</span><span class="n">OrtArenaAllocator</span><span class="p">,</span> <span class="n">OrtMemTypeDefault</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating memory info</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Create input tensors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">features_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">vad_state_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">noise_state_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">denoise_state_tensor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateTensorWithDataAsOrtValue</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">memory_info</span><span class="p">,</span> <span class="n">features_data</span><span class="p">,</span> <span class="mi">42</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">features_shape</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating features tensor</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateTensorWithDataAsOrtValue</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">memory_info</span><span class="p">,</span> <span class="n">vad_state_data</span><span class="p">,</span> <span class="mi">24</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">vad_state_shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vad_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating VAD state tensor</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateTensorWithDataAsOrtValue</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">memory_info</span><span class="p">,</span> <span class="n">noise_state_data</span><span class="p">,</span> <span class="mi">48</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">noise_state_shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">noise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating noise state tensor</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">vad_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">CreateTensorWithDataAsOrtValue</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">memory_info</span><span class="p">,</span> <span class="n">denoise_state_data</span><span class="p">,</span> <span class="mi">96</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">denoise_state_shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">denoise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error creating denoise state tensor</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">vad_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">noise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Prepare input names and tensors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">input_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_vad_state</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                 <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_noise_state</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">input_name_denoise_state</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">input_tensors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">features_tensor</span><span class="p">,</span> <span class="n">vad_state_tensor</span><span class="p">,</span> <span class="n">noise_state_tensor</span><span class="p">,</span> <span class="n">denoise_state_tensor</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Prepare output names
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">output_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_vad_state</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_noise_state</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                  <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">output_name_denoise_state</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">OrtValue</span><span class="o">*</span> <span class="n">output_tensors</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Run inference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">Run</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">session</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">OrtValue</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span><span class="p">)</span><span class="n">input_tensors</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">output_names</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">output_tensors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error running inference</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">vad_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">noise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">denoise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Get output data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span><span class="o">*</span> <span class="n">denoise_output</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="o">*</span> <span class="n">vad_output</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="o">*</span> <span class="n">updated_vad_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="o">*</span> <span class="n">updated_noise_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="o">*</span> <span class="n">updated_denoise_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetTensorMutableData</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">denoise_output</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting denoise output data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetTensorMutableData</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vad_output</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting VAD output data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetTensorMutableData</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">updated_vad_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting updated VAD state data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetTensorMutableData</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">updated_noise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting updated noise state data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">GetTensorMutableData</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">updated_denoise_state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;Error getting updated denoise state data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Store results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memcpy</span><span class="p">(</span><span class="n">gains</span><span class="p">,</span> <span class="n">denoise_output</span><span class="p">,</span> <span class="n">NB_BANDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">vad</span> <span class="o">=</span> <span class="n">vad_output</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Update GRU states with the outputs from the model (for next frame)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">memcpy</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">vad_gru_state</span><span class="p">,</span> <span class="n">updated_vad_state</span><span class="p">,</span> <span class="mi">24</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">noise_gru_state</span><span class="p">,</span> <span class="n">updated_noise_state</span><span class="p">,</span> <span class="mi">48</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memcpy</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">denoise_gru_state</span><span class="p">,</span> <span class="n">updated_denoise_state</span><span class="p">,</span> <span class="mi">96</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">gru_states_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">cleanup</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Cleanup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">features_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">vad_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">noise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">denoise_state_tensor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseValue</span><span class="p">(</span><span class="n">output_tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">api</span><span class="o">-&gt;</span><span class="nf">ReleaseMemoryInfo</span><span class="p">(</span><span class="n">memory_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="33-推理性能对比">3.3 推理性能对比</h3>
<p>可以看到在不需要自己手搓各个算子的C实现，借助ORT就可以实现接近5倍的性能提升，这投入回报比可是不要太高了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">=== Overall Inference Time Statistics ===
</span></span><span class="line"><span class="cl">Total frames processed: 2048
</span></span><span class="line"><span class="cl">Frames with inference: 2047
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ONNX Inference:
</span></span><span class="line"><span class="cl">  Total time: 73.568 ms
</span></span><span class="line"><span class="cl">  Average per frame: 0.036 ms
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">C Inference:
</span></span><span class="line"><span class="cl">  Total time: 349.820 ms
</span></span><span class="line"><span class="cl">  Average per frame: 0.171 ms
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Comparison:
</span></span><span class="line"><span class="cl">  ONNX / C ratio: 0.21x
</span></span><span class="line"><span class="cl">  Speedup: 4.76x (ONNX faster)
</span></span><span class="line"><span class="cl">==========================================</span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="四总结">四、总结</h2>
<p>ORT作为跨平台的推理引擎，在语音降噪模型部署中具有显著优势。正确使用ORT需要：</p>
<ol>
<li><strong>理解基本概念</strong>：掌握InferenceSession、Execution Provider等核心概念</li>
<li><strong>遵循推理流程</strong>：按照标准的加载、准备、执行、获取结果流程</li>
<li><strong>管理隐状态</strong>：对于时序模型，必须正确管理隐状态的传递和更新</li>
<li><strong>性能优化</strong>：根据场景选择合适的优化选项和执行提供者</li>
</ol>
<p>对于实时语音降噪场景，隐状态管理是关键，需要仔细设计状态传递逻辑，确保模型能够正确利用历史信息。</p>
<p>通过合理使用ORT，可以充分发挥深度学习语音降噪模型的性能，实现高效、稳定的实时推理。</p>
<p>另外，ORT还有很多高级特性，大家可以自己摸索尝试下。</p>
<img src="/images/To-Be-Continued.jpeg"/>]]></content:encoded>
    </item>
    <item>
      <title>语音增强算法评估指南</title>
      <link>https://lyapple2008.github.io/posts/202508/2025-08-11-%E9%9F%B3%E9%A2%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/</link>
      <pubDate>Mon, 11 Aug 2025 22:27:28 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202508/2025-08-11-%E9%9F%B3%E9%A2%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/</guid>
      <description>&lt;h1 id=&#34;语音增强算法评估指南&#34;&gt;语音增强算法评估指南&lt;/h1&gt;
&lt;p&gt;如今语音增强算法已成为智能设备、视频会议和助听器等应用的核心，它能从嘈杂环境中“拯救”清晰的语音信号，但如何判断一个算法的好坏？这就是评估的意义所在。今天，我们来聊聊语音增强算法的评估体系，通过一个国际挑战赛作为切入点，带你一步步了解关键指标和计算方法。无论你是初学者还是从业者，这篇文章都能帮你理清思路。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="语音增强算法评估指南">语音增强算法评估指南</h1>
<p>如今语音增强算法已成为智能设备、视频会议和助听器等应用的核心，它能从嘈杂环境中“拯救”清晰的语音信号，但如何判断一个算法的好坏？这就是评估的意义所在。今天，我们来聊聊语音增强算法的评估体系，通过一个国际挑战赛作为切入点，带你一步步了解关键指标和计算方法。无论你是初学者还是从业者，这篇文章都能帮你理清思路。</p>
<h2 id="前言为什么需要评估语音增强算法">前言：为什么需要评估语音增强算法？</h2>
<p>想象一下，你开发了一个语音增强模型，自认为它能完美去除背景噪音。但在实际应用中，用户反馈“声音听起来怪怪的”或“某些噪音下完全失效”。这就是为什么评估至关重要：它提供了一个客观、量化的标准，帮助开发者识别算法的优缺点、优化性能，并与其他方法进行公平比较。</p>
<p>评估的作用主要体现在三个方面：</p>
<ul>
<li><strong>指导开发</strong>：通过指标反馈，迭代模型设计，避免主观偏见。</li>
<li><strong>基准比较</strong>：在竞赛或论文中，用统一标准衡量不同算法的进步。</li>
<li><strong>实际部署</strong>：确保算法在真实场景（如移动端或低信噪比环境）下的鲁棒性和通用性。</li>
</ul>
<p>没有评估，算法开发就像盲人摸象；有了评估，它就成了科学工程。接下来，我们以NeurIPS 2024竞赛轨道下的URGENT 2024挑战为例，深入探讨评估体系。这个挑战聚焦于构建通用语音增强模型，强调在不同噪声、采样率和麦克风配置下的表现。</p>
<h2 id="urgent-2024挑战评估体系的典范">URGENT 2024挑战：评估体系的典范</h2>
<p><a href="https://urgent-challenge.github.io/urgent2024/">URGENT 2024（Universality, Robustness, and Generalizability for EnhancemeNT）</a>挑战旨在解决传统语音增强研究的痛点：许多算法只针对特定条件优化，缺乏跨场景泛化能力。挑战要求参赛者使用统一的公共数据集训练单一模型，处理各种失真（如噪声、混响），并支持不同输入格式（如单/多通道、不同采样率）。</p>
<p>这个挑战的亮点在于其全面评估框架，包括非侵入式（无参考信号）和侵入式（需参考信号）指标，以及下游任务相关指标（如词错误率WER）。它还引入主观MOS（Mean Opinion Score）评分作为最终盲测环节的补充。挑战提供ESPnet工具包的基线模型，鼓励数据增强，但严格限制训练数据来源，确保公平性。</p>
<p>通过这个挑战，我们可以看到评估不仅是“打分”，而是推动行业向真实场景迈进的基准。接下来，重点介绍挑战中使用的核心客观指标：PESQ、ESTOI、SDR、MCD、LSD、DNSMOS和NISQA。</p>
<h2 id="评估指标详解每个指标都在测什么">评估指标详解：每个指标都在测什么？</h2>
<p>语音增强评估指标大致分为侵入式（需要干净参考信号）和非侵入式（无需参考，模拟真实场景）。URGENT 2024挑战选用这些指标来全面考察算法的语音质量、可懂度和保真度。下面逐一解释：</p>
<ul>
<li>
<p><strong>PESQ (Perceptual Evaluation of Speech Quality)</strong>：这是一个侵入式指标，通过比较增强后的语音与参考干净信号，评估感知质量。它关注失真和噪声对人类听觉的影响，得分范围通常为-0.5到4.5（越高越好）。在语音增强中，PESQ常用于客观测试算法的整体质量，尤其适合电话或VoIP场景。</p>
</li>
<li>
<p><strong>ESTOI (Extended Short-Time Objective Intelligibility)</strong>：侵入式指标，专注于评估增强语音的可懂度。它分析短时段信号，预测听者在噪声下的理解能力，得分从0到1（越高表示更易懂）。这个指标特别适用于低信噪比环境，帮助算法优化对人类认知的友好度。</p>
</li>
<li>
<p><strong>SDR (Signal-to-Distortion Ratio)</strong>：侵入式指标，计算期望信号能量与失真（包括噪声和伪影）能量的比率，通常以dB为单位（越高越好）。它评估增强信号的整体保真度，在多通道或复杂噪声场景中非常实用。</p>
</li>
<li>
<p><strong>MCD (Mel-Cepstral Distortion)</strong>：侵入式指标，量化增强信号与参考信号在梅尔倒谱系数上的差异（越低越好）。它聚焦谱失真，提供对感知质量的洞察，常用于评估算法对语音频谱的保留能力。</p>
</li>
<li>
<p><strong>LSD (Log-Spectral Distance)</strong>：侵入式指标，测量增强和参考信号功率谱的对数差异（越低越好）。它评估谱准确性，帮助理解算法如何保留原始语音特征，适用于频域分析。</p>
</li>
<li>
<p><strong>DNSMOS (Deep Noise Suppression Mean Opinion Score)</strong>：非侵入式指标，无需参考信号，使用深度学习模型预测语音质量（模拟人类评分，范围1-5）。它基于人类评级训练，适用于真实场景评估，尤其当干净参考不可用时。</p>
</li>
<li>
<p><strong>NISQA (Non-Intrusive Speech Quality Assessment)</strong>：同样是非侵入式指标，使用机器学习预测感知质量，无需参考。它评估整体语音质量，在参考信号缺失的实际部署中大放异彩。</p>
</li>
</ul>
<p>这些指标组合使用，能从质量、可懂度和失真等多维度评估算法。URGENT挑战强调，非侵入式指标如DNSMOS和NISQA更贴近现实，因为真实环境中往往没有干净参考。</p>
<h2 id="评测数据集从哪里获取如何使用">评测数据集：从哪里获取，如何使用？</h2>
<p>要实际计算这些指标，需要可靠的数据集。URGENT 2024挑战通过其GitHub仓库提供官方评测数据集，托管在Hugging Face上，便于下载和使用。</p>
<ul>
<li><strong>官方评测数据集</strong>：包括验证集、非盲测集和盲测集，地址：https://huggingface.co/datasets/urgent-challenge/urgent2024_official。这些数据集包含各种失真条件下的语音样本，适合测试算法的通用性。</li>
<li><strong>MOS数据集</strong>：额外提供带人类标注MOS分数的语音质量评估数据集，地址：https://huggingface.co/datasets/urgent-challenge/urgent2024_mos。用于主观指标验证。</li>
</ul>
<p>访问方式简单：在Hugging Face平台搜索并下载，或使用Python的datasets库加载。数据集设计覆盖不同噪声、混响和麦克风配置，确保评估的全面性。</p>
<blockquote>
<p>可以参考下面的代码将hugging face中的validataion数据集以wav形式保存在本地，方便后续不同算法进行处理后，对处理结果进行评估。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">datasets</span> <span class="kn">import</span> <span class="n">load_dataset</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">soundfile</span> <span class="k">as</span> <span class="nn">sf</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 参数 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">DATASET_NAME</span> <span class="o">=</span> <span class="s2">&#34;urgent-challenge/urgent2024_official&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">SPLIT</span> <span class="o">=</span> <span class="s2">&#34;validation&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">SAVE_DIR</span> <span class="o">=</span> <span class="s2">&#34;../data/validation&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">NUM_PROC</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># 并行进程数，可以改成你的 CPU 核心数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 目录准备 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">clean_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">,</span> <span class="s2">&#34;clean&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">noisy_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">,</span> <span class="s2">&#34;noisy&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">clean_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">noisy_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 加载数据 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="n">DATASET_NAME</span><span class="p">,</span> <span class="n">SPLIT</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 保存函数 =====</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">save_audio</span><span class="p">(</span><span class="n">example</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">uid</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;id&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># noisy</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;noisy_audio&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy_samples</span><span class="p">,</span> <span class="n">noisy_sr</span> <span class="o">=</span> <span class="n">noisy</span><span class="p">[</span><span class="s2">&#34;array&#34;</span><span class="p">],</span> <span class="n">noisy</span><span class="p">[</span><span class="s2">&#34;sampling_rate&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># clean</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="s2">&#34;clean_audio&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean_samples</span><span class="p">,</span> <span class="n">clean_sr</span> <span class="o">=</span> <span class="n">clean</span><span class="p">[</span><span class="s2">&#34;array&#34;</span><span class="p">],</span> <span class="n">clean</span><span class="p">[</span><span class="s2">&#34;sampling_rate&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 确保采样率一致</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">noisy_sr</span> <span class="o">==</span> <span class="n">clean_sr</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;Sample rate mismatch: noisy=</span><span class="si">{</span><span class="n">noisy_sr</span><span class="si">}</span><span class="s2">, clean=</span><span class="si">{</span><span class="n">clean_sr</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 保存文件路径</span>
</span></span><span class="line"><span class="cl">    <span class="n">noisy_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">noisy_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">.wav&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">clean_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clean_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&#34;</span><span class="si">{</span><span class="n">uid</span><span class="si">}</span><span class="s2">.wav&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 写文件</span>
</span></span><span class="line"><span class="cl">    <span class="n">sf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">noisy_path</span><span class="p">,</span> <span class="n">noisy_samples</span><span class="p">,</span> <span class="n">noisy_sr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">clean_path</span><span class="p">,</span> <span class="n">clean_samples</span><span class="p">,</span> <span class="n">clean_sr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="s2">&#34;noisy_path&#34;</span><span class="p">:</span> <span class="n">noisy_path</span><span class="p">,</span> <span class="s2">&#34;clean_path&#34;</span><span class="p">:</span> <span class="n">clean_path</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ===== 多进程导出 =====</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">save_audio</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_proc</span><span class="o">=</span><span class="n">NUM_PROC</span><span class="p">,</span>      <span class="c1"># 开启多进程</span>
</span></span><span class="line"><span class="cl">    <span class="n">desc</span><span class="o">=</span><span class="s2">&#34;Exporting audio&#34;</span><span class="p">,</span> <span class="c1"># tqdm 进度条描述</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="指标计算实践一步步上手">指标计算实践：一步步上手</h2>
<p>计算这些指标需要工具和脚本。URGENT挑战的GitHub仓库（https://github.com/urgent-challenge/urgent2024_challenge）提供了evaluation_metrics文件夹下的实用脚本，如calculate_intrusive_se_metrics.py（处理PESQ、ESTOI、SDR、MCD、LSD等侵入式指标，支持无限SDR值处理），calculate_nonintrusive_dnsmos.py和calculate_nonintrusive_nisqa.py分别计算DNSMOS和NISQA。</p>
<p><strong>计算步骤示例</strong>：</p>
<blockquote>
<p>参考evaluation_metrics/README.md</p>
</blockquote>
<ol>
<li><strong>数据准备</strong>对validation数据集中的noisy数据进行处理，得到enhanced的数据，按下面的目录结构进行组织
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">📁 /path/to/your/data/
</span></span><span class="line"><span class="cl">├── 📁 enhanced/
</span></span><span class="line"><span class="cl">│   ├── 🔈 fileid_1.wav
</span></span><span class="line"><span class="cl">│   ├── 🔈 fileid_2.wav
</span></span><span class="line"><span class="cl">│   └── ...
</span></span><span class="line"><span class="cl">└── 📁 clean/
</span></span><span class="line"><span class="cl">    ├── 🔈 fileid_1.wav
</span></span><span class="line"><span class="cl">    ├── 🔈 fileid_2.wav
</span></span><span class="line"><span class="cl">    └── ...</span></span></code></pre></td></tr></table>
</div>
</div>
</li>
<li><strong>生成scp文件</strong> 为clean数据和enhance数据生成对应的scp文件，在scp文件中包含两列信息，一列是一个唯一的文件id，一列是文件路径，如下
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># enhanced.scp
</span></span><span class="line"><span class="cl">fileid_1 /path/to/your/data/enhanced/fileid_1.flac
</span></span><span class="line"><span class="cl">fileid_2 /path/to/your/data/enhanced/fileid_2.flac
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># reference.scp
</span></span><span class="line"><span class="cl">fileid_1 /path/to/your/data/clean/fileid_1.flac
</span></span><span class="line"><span class="cl">fileid_2 /path/to/your/data/clean/fileid_2.flac
</span></span><span class="line"><span class="cl">...</span></span></code></pre></td></tr></table>
</div>
</div>
</li>
<li><strong>运行脚本</strong>：例如，对于侵入式指标，运行<code>calculate_intrusive_se_metrics.py</code>输入增强文件和参考文件，输出PESQ等分数。非侵入式如DNSMOS可直接输入增强语音。</li>
<li><strong>示例代码片段</strong>：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="nv">nj</span><span class="o">=</span><span class="m">8</span>  <span class="c1"># Number of parallel CPU jobs for speedup</span>
</span></span><span class="line"><span class="cl"><span class="nv">python</span><span class="o">=</span>python3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">output_prefix</span><span class="o">=</span>metrics_score
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># PESQ, ESTOI, SDR, MCD, LSD</span>
</span></span><span class="line"><span class="cl"><span class="si">${</span><span class="nv">python</span><span class="si">}</span> calculate_intrusive_se_metrics.py <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --ref_scp reference.scp <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --inf_scp enhanced_webrtc.scp <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --output_dir <span class="s2">&#34;</span><span class="si">${</span><span class="nv">output_prefix</span><span class="si">}</span><span class="s2">&#34;</span>/scoring_webrtc <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --nj <span class="si">${</span><span class="nv">nj</span><span class="si">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   --chunksize <span class="m">60</span></span></span></code></pre></td></tr></table>
</div>
</div>
对于批量计算，仓库脚本支持文件夹输入。</li>
</ol>
<p>在实践中，建议结合主观听测（如MOS）验证客观指标，避免“高分低体验”的情况。</p>
<h2 id="结语评估驱动创新">结语：评估驱动创新</h2>
<p>语音增强算法评估不是终点，而是起点。通过URGENT 2024这样的挑战，我们看到评估体系在推动算法向通用、鲁棒方向演进。未来，随着更多非侵入式指标和多模态数据的融入，评估将更贴近真实世界。</p>
<p>最后我们来看下之前介绍的WebRTC NS是什么水平吧，最终的指标如下所示。</p>
<p><img alt="webrtc ns算法评估指标" loading="lazy" src="/images/2025-08-11/validation_webrtc_ns.png"></p>
<p><img alt="noisy" loading="lazy" src="/images/2025-08-11/validation_noisy.png"></p>
<p>可以看到WebRTC NS的评估指标分数只比noisy的分数好一点点，可见还有很大的上升空间。传统算法或多或少都会基于一些假设，而这些假设不只小范围内是生效的，这造成了传统算法的局限性。近年深度学习基于数据驱动的方法，进一步突破这些局限性，极大提高了音频算法的效果上线。下期预告，让我们迈上深度学习时代吧。</p>
<img src="/images/To-Be-Continued.jpeg"/>]]></content:encoded>
    </item>
    <item>
      <title>WebRTC语音降噪之Wiener滤波</title>
      <link>https://lyapple2008.github.io/posts/202507/2025-07-13-webrtc%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA%E4%B9%8Bwiener%E6%BB%A4%E6%B3%A2/</link>
      <pubDate>Mon, 07 Jul 2025 21:59:22 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202507/2025-07-13-webrtc%E8%AF%AD%E9%9F%B3%E9%99%8D%E5%99%AA%E4%B9%8Bwiener%E6%BB%A4%E6%B3%A2/</guid>
      <description>&lt;h1 id=&#34;webrtc中的wiener滤波降噪算法&#34;&gt;WebRTC中的Wiener滤波降噪算法&lt;/h1&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;在实时语音通信系统中，背景噪声的抑制对于提升通话清晰度至关重要。Google 的 WebRTC 项目在其开源语音引擎中实现了高质量的语音降噪模块，其中 Wiener 滤波器作为核心组成部分，结合语音概率估计、多特征建模、噪声谱跟踪等模块构建了一个高度实用的增强框架。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="webrtc中的wiener滤波降噪算法">WebRTC中的Wiener滤波降噪算法</h1>
<h2 id="引言">引言</h2>
<p>在实时语音通信系统中，背景噪声的抑制对于提升通话清晰度至关重要。Google 的 WebRTC 项目在其开源语音引擎中实现了高质量的语音降噪模块，其中 Wiener 滤波器作为核心组成部分，结合语音概率估计、多特征建模、噪声谱跟踪等模块构建了一个高度实用的增强框架。</p>
<p>本文将从 Wiener 滤波理论入手，逐步解析 WebRTC 中该算法的工程实现，其中噪声估计模块和语音概率估计模块已经在之前介绍了，有需要的可以翻阅。</p>
<h2 id="一wiener滤波基础">一、Wiener滤波基础</h2>
<p>Wiener 滤波器是一种最小均方误差（MMSE）估计器，在频域降噪中用于构造一个频点增益函数，以最大程度还原语音信号。</p>
<p>其基本形式为：</p>
<p>$$
G(f) = \frac{\xi(f)}{\xi(f) + 1}
$$</p>
<p>其中：
•	$\xi(f)$：先验信噪比（prior SNR）
•	$G(f)$：频率点 f 的 Wiener 增益</p>
<p>此增益用于对输入频谱进行缩放，从而滤除噪声成分。</p>
<h2 id="二webrtc中的wiener滤波结构">二、WebRTC中的Wiener滤波结构</h2>
<p>在 WebRTC 降噪模块中，Wiener 滤波不是孤立运行，而是集成在一套完整的噪声估计与语音概率建模框架中：</p>

<div class="mermaid">graph TD
    A[输入音频帧] --&gt; B[STFT 分帧]
    B --&gt; C[信号谱 &#43; 噪声谱]
    C --&gt; D[SNR估计（后验&#43;先验）]
    C --&gt; E[LRT / Flatness / Diff 特征提取]
    D &amp; E --&gt; F[Wiener 滤波增益计算]
    F --&gt; G[基于语音概率微调增益]
    G --&gt; H[频谱乘以增益后逆变换]
    H --&gt; I[输出增强语音]</div>
<h2 id="三核心增益计算逻辑">三、核心增益计算逻辑</h2>
<ol>
<li>后验SNR与先验SNR估计
•	后验SNR：使用当前帧信号谱与噪声谱之比
•	先验SNR：</li>
</ol>
<p>$$
\xi_t(f) = \alpha \cdot \frac{|S_{t-1}(f)|^2}{N_{t-1}(f)} + (1 - \alpha) \cdot \max(\gamma_t(f) - 1, 0)
$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// Previous estimate based on previous frame with gain filter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">prev_tsa</span> <span class="o">=</span> <span class="n">spectrum_prev_process_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span>
</span></span><span class="line"><span class="cl">                     <span class="p">(</span><span class="n">prev_noise_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.0001f</span><span class="p">)</span> <span class="o">*</span> <span class="n">filter_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></span></span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>spectrum_prev_process_[i] 为前一帧信号的幅度谱，filter_[i]为前帧的Wiener滤波器增益，两者相乘后就是估计的纯净语音信号，因此prev_tsa就是前一帧的TSA (time-smoothed a priori SNR)</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// Post SNR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">noise_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">post_snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">noise_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.0001f</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">post_snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>只有当信号幅度大于噪声幅度时，才认为有语音信号存在，避免负增益</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">prior_snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.98f</span> <span class="o">*</span> <span class="n">prev_estimate</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="mf">0.98f</span><span class="p">)</span> <span class="o">*</span> <span class="n">post_snr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></span></span></code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>0.98 是平滑因子，表示以历史先验估计为主，防止突变</p>
</blockquote>
<ol start="2">
<li>基本增益计算</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="c1">// 参变维纳滤波器，参考《语音增强--理论与实践》,通过over_subtraction_factor来控制降噪力度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">filter_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">snr_prior</span> <span class="o">/</span> <span class="p">(</span><span class="n">suppression_params_</span><span class="p">.</span><span class="n">over_subtraction_factor</span> <span class="o">+</span> <span class="n">snr_prior</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">filter_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">max</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">min</span><span class="p">(</span><span class="n">filter_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">1.f</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                          <span class="n">suppression_params_</span><span class="p">.</span><span class="n">minimum_attenuating_gain</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<img src="/images/2025-07-13/wiener_over_subtraction_factor.png"/>
<h2 id="四增益微调语音概率辅助因子">四、增益微调：语音概率辅助因子</h2>
<p>虽然 Wiener 滤波器理论上是最优的，但其在以下情况下仍存在问题：
•	SNR 估计不准确
•	缺乏上下文判断
•	语音尾音易被吞掉</p>
<p>因此 WebRTC 引入了语音概率估计模块，通过以下方式微调 Wiener 增益：</p>
<p>scale = prior_prob * scale1 + (1 - prior_prob) * scale2;</p>
<p>其中：
•	scale1: 当前是语音 → 增强增益
•	scale2: 当前是噪声 → 抑制增益
•	prior_prob: 通过 LRT、Spectral Flatness、Spectral Diff 等特征综合估计</p>
<h2 id="五高带处理">五、高带处理</h2>
<p>在WebRTC的噪声抑制算法中，高频带（8kHz以上）没有直接使用频域Wiener滤波处理，而是在时域统一增益处理，这里即是因为语音大部分是在低带部分，同时也是为了效率减少计算量。接下我们来分析WebRTC的噪声抑制算法是如何通过低带的信息计算高频带增益的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// Computes the attenuating gain for the noise suppression of the upper bands.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="nf">ComputeUpperBandsGain</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">minimum_attenuating_gain</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">filter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">speech_probability</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">prev_analysis_signal_spectrum</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">signal_spectrum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Average speech prob and filter gain for the end of the lowest band.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">constexpr</span> <span class="kt">int</span> <span class="n">kNumAvgBins</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kOneByNumAvgBins</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="n">kNumAvgBins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 计算低带中最后的的kNumAvgBins个频点（靠近8kHz附近）的平均语音概率和平均增益
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">avg_prob_speech</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">avg_filter_gain</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">kFftSizeBy2Plus1</span> <span class="o">-</span> <span class="n">kNumAvgBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">avg_prob_speech</span> <span class="o">+=</span> <span class="n">speech_probability</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">avg_filter_gain</span> <span class="o">+=</span> <span class="n">filter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">avg_prob_speech</span> <span class="o">=</span> <span class="n">avg_prob_speech</span> <span class="o">*</span> <span class="n">kOneByNumAvgBins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">avg_filter_gain</span> <span class="o">=</span> <span class="n">avg_filter_gain</span> <span class="o">*</span> <span class="n">kOneByNumAvgBins</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If the speech was suppressed by a component between Analyze and Process, an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// example being by an AEC, it should not be considered speech for the purpose
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// of high band suppression. To that end, the speech probability is scaled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// accordingly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">sum_analysis_spectrum</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">sum_processing_spectrum</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum_analysis_spectrum</span> <span class="o">+=</span> <span class="n">prev_analysis_signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum_processing_spectrum</span> <span class="o">+=</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// The magnitude spectrum computation enforces the spectrum to be strictly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// positive.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">RTC_DCHECK_GT</span><span class="p">(</span><span class="n">sum_analysis_spectrum</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">avg_prob_speech</span> <span class="o">*=</span> <span class="n">sum_processing_spectrum</span> <span class="o">/</span> <span class="n">sum_analysis_spectrum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Compute gain based on speech probability.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">gain</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">+</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="nf">tanh</span><span class="p">(</span><span class="mf">2.f</span> <span class="o">*</span> <span class="n">avg_prob_speech</span> <span class="o">-</span> <span class="mf">1.f</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Combine gain with low band gain.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">avg_prob_speech</span> <span class="o">&gt;=</span> <span class="mf">0.5f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.25f</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="mf">0.75f</span> <span class="o">*</span> <span class="n">avg_filter_gain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">avg_filter_gain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Make sure gain is within flooring range.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="nf">min</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">max</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">minimum_attenuating_gain</span><span class="p">),</span> <span class="mf">1.f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol>
<li>选取低带频谱中最后32个bin（即靠近8kHz的部分），计算平均语音概率和平均Wiener滤波器增益</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">avg_prob_speech：语音存在的可能性（0~1）
</span></span><span class="line"><span class="cl">avg_filter_gain：低带最后段的增益（代表频谱高频变化）</span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="2">
<li>处理前后谱能量比修正语音概率</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">avg_prob_speech</span> <span class="o">*=</span> <span class="n">sum_processing_spectrum</span> <span class="o">/</span> <span class="n">sum_analysis_spectrum</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>sum_analysis_spectrum：分析阶段的谱（原始 noisy 语音）</li>
<li>sum_processing_spectrum：处理阶段的谱（可能被 AEC、AGC 等处理）
⚠️ 如果语音信号被其他模块（比如回声消除）削弱了，而估计器没注意到，就会过度抑制高带，这里通过能量比进行修正，防止“假静音”影响高频压制判断。</li>
</ul>
<ol start="3">
<li>使用 tanh 平滑映射为增益因子</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">+</span> <span class="nf">tanh</span><span class="p">(</span><span class="mf">2.f</span> <span class="o">*</span> <span class="n">avg_prob_speech</span> <span class="o">-</span> <span class="mf">1.f</span><span class="p">));</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>tanh 函数做了一个S型映射：使得 01 的 avg_prob_speech 映射为 01 的增益，但中心更敏感，平滑、可导。</li>
<li>当语音概率高于 0.5 时增益快速上升；低于 0.5 时快速下降。</li>
</ul>
<ol start="4">
<li>将该增益和低带平均滤波器增益融合</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">avg_prob_speech</span> <span class="o">&gt;=</span> <span class="mf">0.5f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.25f</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="mf">0.75f</span> <span class="o">*</span> <span class="n">avg_filter_gain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl">  <span class="n">gain</span> <span class="o">=</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="n">avg_filter_gain</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>当语音概率较高，以低带滤波器为主（强调保留语音的高频特征）</li>
<li>当语音概率较低，用概率增益和滤波增益各一半权重</li>
</ul>
<ol start="5">
<li>高带延时处理</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">DelaySignal</span><span class="p">(</span><span class="n">y_band</span><span class="p">,</span> <span class="n">channels_</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">process_delay_memory</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">delayed_frame</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>低带由于滤波器组分析→合成，会产生系统延时，因此在低带和高带合成前，需要将高带信号进行延时操作，与低带信号进行对齐。</p>
<h2 id="六小结与启发">六、小结与启发</h2>
<p>WebRTC 的 Wiener 降噪模块体现了“理论 + 工程”的完美结合：</p>
<table>
  <thead>
      <tr>
          <th>模块</th>
          <th>功能</th>
          <th>工程优化</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Wiener 增益</td>
          <td>降噪核心</td>
          <td>加入先验平滑与概率调节</td>
      </tr>
      <tr>
          <td>SNR估计</td>
          <td>支持增益计算</td>
          <td>TSA平滑，避免突变</td>
      </tr>
      <tr>
          <td>语音概率</td>
          <td>增益微调</td>
          <td>三特征融合 + Sigmoid 映射</td>
      </tr>
      <tr>
          <td>噪声谱估计</td>
          <td>保证准确性</td>
          <td>分位数估计 + 启动模型</td>
      </tr>
  </tbody>
</table>
<p>这种设计保证了算法在实时语音场景中的鲁棒性、稳定性与可听感提升效果。</p>
<img src="/images/To-Be-Continued.jpeg"/>
]]></content:encoded>
    </item>
    <item>
      <title>WebRTC语音降噪之语音概率估计</title>
      <link>https://lyapple2008.github.io/posts/202506/2025-06-30-%E8%AF%AD%E9%9F%B3%E6%A6%82%E7%8E%87%E4%BC%B0%E8%AE%A1/</link>
      <pubDate>Mon, 30 Jun 2025 21:36:39 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202506/2025-06-30-%E8%AF%AD%E9%9F%B3%E6%A6%82%E7%8E%87%E4%BC%B0%E8%AE%A1/</guid>
      <description>&lt;p&gt;WebRTC的语音降噪算法中实现了一个频点维度的语音概率估计器SpeechProbabilityEstimator，本质是一个多特征融合的线性分类器。统计计算以下三种特征，&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>WebRTC的语音降噪算法中实现了一个频点维度的语音概率估计器SpeechProbabilityEstimator，本质是一个多特征融合的线性分类器。统计计算以下三种特征，</p>
<ul>
<li>LRT</li>
<li>Spectral Flatness  谱平坦度</li>
<li>Spectral Difference 谱差</li>
</ul>
<p>通过tanh将特征变化映射到概率值，使用不同的width参数来调节敏感度，线性加权融合到得最终的语音概率。
接下来完整分析 WebRTC 中用于语音概率估计的三个核心特征（indicator0, indicator1, indicator2）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># 代码位置</span>
</span></span><span class="line"><span class="cl"><span class="n">modules</span><span class="o">/</span><span class="n">audio_processing</span><span class="o">/</span><span class="n">ns</span><span class="o">/</span><span class="n">speech_probability_estimator</span><span class="o">.</span><span class="n">h</span>
</span></span><span class="line"><span class="cl"><span class="n">modules</span><span class="o">/</span><span class="n">audio_processing</span><span class="o">/</span><span class="n">ns</span><span class="o">/</span><span class="n">speech_probability_estimator</span><span class="o">.</span><span class="n">cc</span>
</span></span><span class="line"><span class="cl"><span class="n">modules</span><span class="o">/</span><span class="n">audio_processing</span><span class="o">/</span><span class="n">ns</span><span class="o">/</span><span class="n">signal_model_estimator</span><span class="o">.</span><span class="n">cc</span>
</span></span><span class="line"><span class="cl"><span class="n">modules</span><span class="o">/</span><span class="n">audio_processing</span><span class="o">/</span><span class="n">ns</span><span class="o">/</span><span class="n">signal_model_estimator</span><span class="o">.</span><span class="n">h</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="indicator0-likelihood-ratio-test-lrt">indicator0: Likelihood Ratio Test (LRT)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// Updates the log LRT measures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">UpdateSpectralLrt</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">prior_snr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">post_snr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">avg_log_lrt</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">float</span><span class="o">*</span> <span class="n">lrt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">RTC_DCHECK</span><span class="p">(</span><span class="n">lrt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">+</span> <span class="mf">2.f</span> <span class="o">*</span> <span class="n">prior_snr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="mf">2.f</span> <span class="o">*</span> <span class="n">prior_snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">tmp1</span> <span class="o">+</span> <span class="mf">0.0001f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">bessel_tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">post_snr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.f</span><span class="p">)</span> <span class="o">*</span> <span class="n">tmp2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">avg_log_lrt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span>
</span></span><span class="line"><span class="cl">        <span class="mf">.5f</span> <span class="o">*</span> <span class="p">(</span><span class="n">bessel_tmp</span> <span class="o">-</span> <span class="nf">LogApproximation</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">-</span> <span class="n">avg_log_lrt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">log_lrt_time_avg_k_sum</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_lrt_time_avg_k_sum</span> <span class="o">+=</span> <span class="n">avg_log_lrt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">lrt</span> <span class="o">=</span> <span class="n">log_lrt_time_avg_k_sum</span> <span class="o">*</span> <span class="n">kOneByFftSizeBy2Plus1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>LRT衡量的是，当前观察到的频谱，更像是语音信号，还是更像噪声，是在两种假设之间进行比较：</p>
<ul>
<li>$H_0$: 当前帧是纯噪声帧</li>
<li>$H_1$: 当前帧是语音 + 噪声帧</li>
</ul>
<p>通过计算：</p>
<p>$$
\Lambda = \log \left( \frac{P(X | H_1)}{P(X | H_0)} \right)
$$</p>
<p>其中：</p>
<ul>
<li>$P(X|H_1)$：给定为语音的条件下，观测值 X 出现的概率；</li>
<li>$P(X|H_0)$：给定为噪声的条件下，观测值 X 出现的概率；</li>
</ul>
<p>最终近似简化为（推导过程跳过了，找了一些资料，没看太懂🙈）：</p>
<p>$$
\text{LRT}(k) \approx  \frac{(1 + \gamma_k) \cdot 2 \cdot \xi_k}{1 + 2 \cdot \xi_k} - \log(1 + 2 \cdot \xi_k)
$$</p>
<p>其中：</p>
<ul>
<li>$\xi_k$：频点 k 的先验 SNR；</li>
<li>$\gamma_k$：频点 k 的后验 SNR；</li>
<li>LRT 越大，表明信号更像语音；</li>
<li>LRT 越小，说明更像噪声。</li>
</ul>
<p>再通过tanh函数映射到[0, 1]的区间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="c1">// Width parameter in sigmoid map for prior model.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kWidthPrior0</span> <span class="o">=</span> <span class="mf">4.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Width for pause region: lower range, so increase width in tanh map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kWidthPrior1</span> <span class="o">=</span> <span class="mf">2.f</span> <span class="o">*</span> <span class="n">kWidthPrior0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Average LRT feature: use larger width in tanh map for pause regions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">width_prior</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">lrt</span> <span class="o">&lt;</span> <span class="n">prior_model</span><span class="p">.</span><span class="n">lrt</span> <span class="o">?</span> <span class="nl">kWidthPrior1</span> <span class="p">:</span> <span class="n">kWidthPrior0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Compute indicator function: sigmoid map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">indicator0</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="nf">tanh</span><span class="p">(</span><span class="n">width_prior</span> <span class="o">*</span> <span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">lrt</span> <span class="o">-</span> <span class="n">prior_model</span><span class="p">.</span><span class="n">lrt</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1.f</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="indicator1-spectral-flatness-谱平坦度">indicator1: Spectral Flatness 谱平坦度</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// Updates the spectral flatness based on the input spectrum.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">UpdateSpectralFlatness</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">signal_spectrum</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">signal_spectral_sum</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="o">*</span> <span class="n">spectral_flatness</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">RTC_DCHECK</span><span class="p">(</span><span class="n">spectral_flatness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Compute log of ratio of the geometric to arithmetic mean (handle the log(0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// separately).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kAveraging</span> <span class="o">=</span> <span class="mf">0.3f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">avg_spect_flatness_num</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">spectral_flatness</span> <span class="o">-=</span> <span class="n">kAveraging</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">spectral_flatness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">avg_spect_flatness_num</span> <span class="o">+=</span> <span class="nf">LogApproximation</span><span class="p">(</span><span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">avg_spect_flatness_denom</span> <span class="o">=</span> <span class="n">signal_spectral_sum</span> <span class="o">-</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">avg_spect_flatness_denom</span> <span class="o">=</span> <span class="n">avg_spect_flatness_denom</span> <span class="o">*</span> <span class="n">kOneByFftSizeBy2Plus1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">avg_spect_flatness_num</span> <span class="o">=</span> <span class="n">avg_spect_flatness_num</span> <span class="o">*</span> <span class="n">kOneByFftSizeBy2Plus1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">spectral_tmp</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="nf">ExpApproximation</span><span class="p">(</span><span class="n">avg_spect_flatness_num</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_spect_flatness_denom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Time-avg update of spectral flatness feature.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="n">spectral_flatness</span> <span class="o">+=</span> <span class="n">kAveraging</span> <span class="o">*</span> <span class="p">(</span><span class="n">spectral_tmp</span> <span class="o">-</span> <span class="o">*</span><span class="n">spectral_flatness</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>
<p>谱平坦度的定义
$$
\text{SFM} = \frac{\left( \prod_{i=1}^{N} X_i \right)^{1/N}}{\frac{1}{N} \sum_{i=1}^{N} X_i}
= \frac{\text{几何均值}}{\text{算术均值}}
$$</p>
</li>
<li>
<p>为什么谱平坦度可以区分语音和噪声
首先从纯数学角度，根据均值不等式有：几何均值 &lt;= 算数均值</p>
</li>
</ul>
<ol>
<li>当所有元素相等时，两者相等</li>
<li>当元素差异越大时，几何均值相对算数均值越小，说明“越不平坦”</li>
</ol>
<p>再对应到语音降噪应用：</p>
<ol>
<li>噪声（尤其是白噪声）：频带能量均匀，几何均值 ≈ 算数均值，Flatness ≈ 1</li>
<li>语音信号：存在能量集中（共振峰），几何均值 ≪ 算数均值，Flatness 接近 0</li>
</ol>
<blockquote>
<p>因此谱平坦度 = 能量分布的“均匀性量尺” → 能直接用来做语音/噪声分类特征！</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<ol>
<li>计算几何均值</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">avg_spect_flatness_num</span> <span class="o">+=</span> <span class="nf">LogApproximation</span><span class="p">(</span><span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">avg_spect_flatness_num</span> <span class="o">=</span> <span class="n">avg_spect_flatness_num</span> <span class="o">*</span> <span class="n">kOneByFftSizeBy2Plus1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>等价于下面的式子，先算log版本</p>
<p>$$
\exp\left( \frac{1}{N} \sum \log(X_i) \right)
$$</p>
<p>再做指数运算还原为几何均值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">ExpApproximation</span><span class="p">(</span><span class="n">avg_spect_flatness_num</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="2">
<li>计算算数均值（去掉DC分量）</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">avg_spect_flatness_denom</span> <span class="o">=</span> <span class="n">signal_spectral_sum</span> <span class="o">-</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">avg_spect_flatness_denom</span> <span class="o">=</span> <span class="n">avg_spect_flatness_denom</span> <span class="o">*</span> <span class="n">kOneByFftSizeBy2Plus1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="3">
<li>得到谱平坦度</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">spectral_tmp</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="nf">ExpApproximation</span><span class="p">(</span><span class="n">avg_spect_flatness_num</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_spect_flatness_denom</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="4">
<li>平滑更新</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="c1">// Time-avg update of spectral flatness feature.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="n">spectral_flatness</span> <span class="o">+=</span> <span class="n">kAveraging</span> <span class="o">*</span> <span class="p">(</span><span class="n">spectral_tmp</span> <span class="o">-</span> <span class="o">*</span><span class="n">spectral_flatness</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="indicator2-spectral-difference-谱模板差异">indicator2: Spectral Difference 谱模板差异</h2>
<p>Spectral Difference频谱差异是用于衡量当前帧的频谱与已学习噪声模板之间的差异程度。其基本思想是：</p>
<blockquote>
<p>如果当前帧的频谱结构与噪声模板相似，则可能是噪声；如果差异大，则可能是语音。</p>
</blockquote>
<ol>
<li>总体计算公式
$$
\text{SpectralDiff} = \text{Var}(X) - \frac{[\text{Cov}(X, Y)]^2}{\text{Var}(Y)}
$$</li>
</ol>
<p>其中：
•	X：当前帧的 信号频谱；
•	Y：历史平均的 噪声频谱（称为 conservative noise spectrum）；
•	$\mathrm{Var}$：方差（描述“起伏程度”）；
•	$\mathrm{Cov}$：协方差（描述“是否联动”）。</p>
<ol start="2">
<li>为什么它能衡量相似程序？</li>
</ol>
<p>从统计角度看，Var(X) - Cov(X, Y)^2 / Var(Y) 是当前帧中 与过去模板不一致的能量。如果：</p>
<ul>
<li>如果 signal ≈ noise（噪声帧）：→ covariance² / noise_variance ≈ signal_variance → spectral_diff ≈ 0</li>
<li>如果 signal 包含语音成分（结构和噪声不一样）：→ covariance 小，spectral_diff 增大</li>
</ul>
<p>这个公式本质上等价于：</p>
<p>Var(Residual) = Var(Signal) - Var(ProjectedNoiseComponent)</p>
<p>即：当前帧中除了可以用噪声解释的部分，剩下有多少“异常能量”</p>
<h2 id="多特征融合">多特征融合</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="c1">// Combine the indicator function with the feature weights.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">ind_prior</span> <span class="o">=</span> <span class="n">prior_model</span><span class="p">.</span><span class="n">lrt_weighting</span> <span class="o">*</span> <span class="n">indicator0</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                    <span class="n">prior_model</span><span class="p">.</span><span class="n">flatness_weighting</span> <span class="o">*</span> <span class="n">indicator1</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                    <span class="n">prior_model</span><span class="p">.</span><span class="n">difference_weighting</span> <span class="o">*</span> <span class="n">indicator2</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>最终组合这三个指标：</p>
<ul>
<li>每个特征都有独立的权重</li>
<li>互补性强，提升稳健性</li>
</ul>
<p>举例子：</p>
<table>
  <thead>
      <tr>
          <th>情况</th>
          <th>LRT</th>
          <th>Flatness</th>
          <th>Spectral Diff</th>
          <th>判断结果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>短促辅音 [k]</td>
          <td>高</td>
          <td>高（像噪声）</td>
          <td>低（像模板）</td>
          <td>不能仅靠 flatness 判断，indicator2 弥补</td>
      </tr>
      <tr>
          <td>背景突发噪声</td>
          <td>高</td>
          <td>高</td>
          <td>高</td>
          <td>indicator2 抑制误判</td>
      </tr>
      <tr>
          <td>语音暂停期</td>
          <td>低</td>
          <td>高</td>
          <td>高</td>
          <td>三项均为低，VAD 静音</td>
      </tr>
  </tbody>
</table>
<h2 id="计算频点的后验语音概率">计算频点的后验语音概率</h2>
<ul>
<li>平滑更新先验语音概率</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="c1">// Compute the prior probability.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">prior_speech_prob_</span> <span class="o">+=</span> <span class="mf">0.1f</span> <span class="o">*</span> <span class="p">(</span><span class="n">ind_prior</span> <span class="o">-</span> <span class="n">prior_speech_prob_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Make sure probabilities are within range: keep floor to 0.01.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">prior_speech_prob_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">max</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="nf">min</span><span class="p">(</span><span class="n">prior_speech_prob_</span><span class="p">,</span> <span class="mf">1.f</span><span class="p">),</span> <span class="mf">0.01f</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>计算后验语音概率
因为prior_speech_prob_是通过历史信息估计的当前帧语音概率，因此这个概率称为先验语音概率。实际使用时我们不需要我们观察到当帧后给出的概率，即后验语音概率。</li>
</ul>
<p>贝叶斯定理给出后验概率公式：</p>
<p>$$
P(H_1 \mid X) = \frac{P(H_1) \cdot P(X \mid H_1)}{P(H_1) \cdot P(X \mid H_1) + P(H_0) \cdot P(X \mid H_0)}
$$</p>
<p>我们引入：
•	$\text{Prior} = P(H_1)$
•	$\text{Gain} = \frac{1 - \text{Prior}}{\text{Prior}}$
•	$\text{LRT} = \frac{P(X \mid H_1)}{P(X \mid H_0)}$</p>
<p>可得后验语音概率（简化推导）：</p>
<p>$$
P(H_1 \mid X) = \frac{1}{1 + \text{Gain} \cdot \frac{1}{\text{LRT}}}
$$</p>
<p>这正是代码中这段的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">  <span class="c1">// Final speech probability: combine prior model with LR factor:.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">float</span> <span class="n">gain_prior</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="n">prior_speech_prob_</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">prior_speech_prob_</span> <span class="o">+</span> <span class="mf">0.0001f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">inv_lrt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ExpApproximationSignFlip</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">avg_log_lrt</span><span class="p">,</span> <span class="n">inv_lrt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">speech_probability_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">+</span> <span class="n">gain_prior</span> <span class="o">*</span> <span class="n">inv_lrt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>其中：
•	gain_prior = (1 - prior_speech_prob_) / (prior_speech_prob_ + ε)
•	inv_lrt[i] = e^{-avg_log_lrt[i]} ≈ 1 / LRT （指数近似）</p>
<h2 id="利用语音概率辅助更新噪声谱">利用语音概率辅助更新噪声谱</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NoiseEstimator</span><span class="o">::</span><span class="nf">PostUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="n">speech_probability</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">float</span><span class="p">,</span> <span class="n">kFftSizeBy2Plus1</span><span class="o">&gt;</span> <span class="n">signal_spectrum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Time-avg parameter for noise_spectrum update.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kNoiseUpdate</span> <span class="o">=</span> <span class="mf">0.9f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">float</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">kNoiseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kFftSizeBy2Plus1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">prob_speech</span> <span class="o">=</span> <span class="n">speech_probability</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">float</span> <span class="n">prob_non_speech</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">-</span> <span class="n">prob_speech</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Temporary noise update used for speech frames if update value is less
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// than previous.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">noise_update_tmp</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">gamma</span> <span class="o">*</span> <span class="n">prev_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">prob_non_speech</span> <span class="o">*</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                         <span class="n">prob_speech</span> <span class="o">*</span> <span class="n">prev_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Time-constant based on speech/noise_spectrum state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">gamma_old</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Increase gamma for frame likely to be seech.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">constexpr</span> <span class="kt">float</span> <span class="n">kProbRange</span> <span class="o">=</span> <span class="mf">.2f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">gamma</span> <span class="o">=</span> <span class="n">prob_speech</span> <span class="o">&gt;</span> <span class="n">kProbRange</span> <span class="o">?</span> <span class="mf">.99f</span> <span class="o">:</span> <span class="n">kNoiseUpdate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Conservative noise_spectrum update.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">prob_speech</span> <span class="o">&lt;</span> <span class="n">kProbRange</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">conservative_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span>
</span></span><span class="line"><span class="cl">          <span class="mf">0.05f</span> <span class="o">*</span> <span class="p">(</span><span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">conservative_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Noise_spectrum update.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">==</span> <span class="n">gamma_old</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_update_tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">gamma</span> <span class="o">*</span> <span class="n">prev_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">prob_non_speech</span> <span class="o">*</span> <span class="n">signal_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                           <span class="n">prob_speech</span> <span class="o">*</span> <span class="n">prev_noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Allow for noise_spectrum update downwards: If noise_spectrum update
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// decreases the noise_spectrum, it is safe, so allow it to happen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="nf">min</span><span class="p">(</span><span class="n">noise_spectrum_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">noise_update_tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>上面这段代码是webrtc中结合语音概率，对之前基于分位数估计得到的噪声谱，进行进一步修正的过程。</p>
<p>那为什么已经有了基于分位数的噪声估计，还需要在PostUpdate()中进行进一步修正呢？</p>
<p>如下表，我们对比与初始分位数估计的关系和区别</p>
<table>
  <thead>
      <tr>
          <th>特征</th>
          <th>PreUpdate() 中的分位数估计</th>
          <th>PostUpdate() 中的时间平均更新</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>原理</td>
          <td>统计过往帧的底噪分布（log-domain）</td>
          <td>利用当前帧的语音概率进行时间递归更新</td>
      </tr>
      <tr>
          <td>更新维度</td>
          <td>横向（跨帧分布）</td>
          <td>纵向（帧内时间平滑）</td>
      </tr>
      <tr>
          <td>响应特性</td>
          <td>对背景缓慢变化有响应，对突发语音稳健</td>
          <td>在语音帧期间抑制更新，非语音帧中轻微修正</td>
      </tr>
      <tr>
          <td>对应变量</td>
          <td>quantile_noise_estimator_.Estimate(&hellip;) → noise_spectrum_[]</td>
          <td>初值	noise_spectrum_[] → 平滑动态追踪修正</td>
      </tr>
      <tr>
          <td>目的</td>
          <td>建立初步噪声模型</td>
          <td>细化并动态追踪噪声谱</td>
      </tr>
  </tbody>
</table>
<h3 id="总结为什么需要-postupdate">总结：为什么需要 PostUpdate？</h3>
<ul>
<li>分位数估计（PreUpdate）很强健，但慢。</li>
<li>PostUpdate 提供 快速、平滑、概率驱动 的动态调整机制。</li>
<li>防止语音能量污染噪声估计；</li>
<li>保持噪声谱能持续跟踪 非平稳噪声（如空调开关、风声变化）；</li>
<li>为后续 Wiener 滤波器提供更可靠的噪声谱输入。</li>
</ul>
<p>Ok! 到这里WebRTC就真正完成了噪声谱的估计，接下继续分享WebRTC语音降噪代码.</p>
<h4 id="to-be-continue">To Be Continue!!!</h4>
]]></content:encoded>
    </item>
    <item>
      <title>WebRTC语音降噪之基于分位数的噪声估计</title>
      <link>https://lyapple2008.github.io/posts/202506/2025-06-28-%E5%9F%BA%E4%BA%8E%E5%88%86%E4%BD%8D%E6%95%B0%E7%9A%84%E5%99%AA%E5%A3%B0%E4%BC%B0%E8%AE%A1/</link>
      <pubDate>Sat, 28 Jun 2025 15:38:44 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202506/2025-06-28-%E5%9F%BA%E4%BA%8E%E5%88%86%E4%BD%8D%E6%95%B0%E7%9A%84%E5%99%AA%E5%A3%B0%E4%BC%B0%E8%AE%A1/</guid>
      <description>&lt;h2 id=&#34;噪声估计的作用&#34;&gt;噪声估计的作用&lt;/h2&gt;
&lt;p&gt;噪声估计算法在整个语音降噪系统中起到核心支撑作用，先验SNR和后验SNR的计算都依赖于当前帧的噪声功率谱估计。若噪声估计偏低，会导致保留太多噪声（过度保留）；若噪声估计偏高，会把语音当作噪声过滤掉（语音失真）； 更新不稳定，整体听感时好时坏，忽大忽小，出现”泵声“、”音乐噪声“现象。本文介绍WebRTC中目前使用的基于分位数的噪声估计算法，及其在工程实现中的巧妙之处。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="噪声估计的作用">噪声估计的作用</h2>
<p>噪声估计算法在整个语音降噪系统中起到核心支撑作用，先验SNR和后验SNR的计算都依赖于当前帧的噪声功率谱估计。若噪声估计偏低，会导致保留太多噪声（过度保留）；若噪声估计偏高，会把语音当作噪声过滤掉（语音失真）； 更新不稳定，整体听感时好时坏，忽大忽小，出现”泵声“、”音乐噪声“现象。本文介绍WebRTC中目前使用的基于分位数的噪声估计算法，及其在工程实现中的巧妙之处。</p>
<h2 id="什么是基于分位数的噪声估计">什么是基于分位数的噪声估计</h2>
<p>基于分位数的噪声估计算法是一种利用信号统计特性区分噪声和语音的自适应方法。其核心原理在于：噪声的能量分布通常集中在低分位区域，而语音信号的能量分布会抬高高分位数。</p>
<h2 id="webrtc中的实现解读妙呀">WebRTC中的实现解读（妙呀）</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 代码位置
</span></span><span class="line"><span class="cl">modules/audio_processing/ns/quantile_noise_estimator.h 
</span></span><span class="line"><span class="cl">modules/audio_processing/ns/quantile_noise_estimator.cc</span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="分位数计算">分位数计算</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">log_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.25f</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.75f</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>以上是WebRTC中分位数计算的代码，它表示25%分位数估计，下面我们来逐步说明为什么这段代码可以计算25%分位数。</p>
<h4 id="什么是分位数">什么是分位数？</h4>
<p>以25%分位数为例，它表示：如果你观察一组数，有25%是小于它的，有75%是大于它的。
比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">数据（已排序）：[1, 2, 3, 4, 5, 6, 7, 8, 9]
</span></span><span class="line"><span class="cl">0.25分位数 ≈ 第3个数 = 3</span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="非对称更新的数学直觉">非对称更新的数学直觉</h4>
<p>设：当前估计值为Q，当前观测值为X</p>
<p>我们每帧更新规则如下：</p>
<table>
  <thead>
      <tr>
          <th>情况</th>
          <th>更新量</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>x &gt; Q</td>
          <td>Q ← Q + 0.25 × step</td>
          <td>当前值太大，稍微拉高估计值</td>
      </tr>
      <tr>
          <td>x &lt; Q</td>
          <td>Q ← Q - 0.75 × step</td>
          <td>当前值太小，大幅拉低估计值</td>
      </tr>
  </tbody>
</table>
<h4 id="收敛分析平衡点--25分位数">收敛分析：平衡点 = 25%分位数</h4>
<p>考虑连续观察大量值 {x₁, x₂, &hellip;, xₙ}，估计值 Q 如果在一个固定位置附近波动，那它一定满足：
平均上调量 ≈ 平均下调量，也就是说，在那个点：</p>
<blockquote>
<p>上调概率 × 上调步长 = 下调概率 × 下调步长</p>
</blockquote>
<p>其中：</p>
<ul>
<li>上调概率 p_up = P(x &gt; Q)</li>
<li>下调概率 p_down = P(x &lt; Q) = 1 - p_up</li>
<li>上调步长 = 0.25</li>
<li>下调步长 = 0.75
计算可以得到：p_down = 0.25</li>
</ul>
<p>✅ 说明这个估计最终会逼近 25% 分位数！</p>
<blockquote>
<p>这个分位数的实现真是妙了呀，避免了常规分位计算需要排序的问题，同时还可以实时更新。👍</p>
</blockquote>
<h3 id="多分位数估计分时更新">多分位数估计分时更新</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">  <span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">simultaneous</span> <span class="n">estimates</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">kSimult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span> <span class="o">+=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kFftSizeBy2Plus1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="ne">float</span> <span class="n">one_by_counter_plus_1</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kFftSizeBy2Plus1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="n">Update</span> <span class="nb">log</span> <span class="n">quantile</span> <span class="n">estimate</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="ne">float</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="n">f</span> <span class="err">?</span> <span class="mf">40.</span><span class="n">f</span> <span class="o">/</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span> <span class="mf">40.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="ne">float</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">one_by_counter_plus_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">log_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.25</span><span class="n">f</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.75</span><span class="n">f</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="o">//</span> <span class="n">Update</span> <span class="n">density</span> <span class="n">estimate</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">      <span class="n">constexpr</span> <span class="ne">float</span> <span class="n">kWidth</span> <span class="o">=</span> <span class="mf">0.01</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">constexpr</span> <span class="ne">float</span> <span class="n">kOneByWidthPlus2</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="n">f</span> <span class="o">*</span> <span class="n">kWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">log_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">kWidth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">kOneByWidthPlus2</span><span class="p">)</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">                      <span class="n">one_by_counter_plus_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">kLongStartupPhaseBlocks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">num_updates_</span> <span class="o">&gt;=</span> <span class="n">kLongStartupPhaseBlocks</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">quantile_index_to_return</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>kLongStartupPhaseBlocks=200，意味着分位数估计在200帧后，即2秒，才会更新重置输出估计结果。webrtc为了减少响应延迟，设置了三个错位的独立分位数估计器，如下代码，可以看到每一个分位数估计器的更新计数是错开的，这样可以达到每67帧，即670ms，就会有一个分位数估计器进行重置更新输出估计结果，从而达到快速响应的效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl">  <span class="n">constexpr</span> <span class="ne">float</span> <span class="n">kOneBySimult</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="n">kSimult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSimult</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">counter_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">kLongStartupPhaseBlocks</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">kOneBySimult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h3 id="利用密度估计实现自适应步长">利用”密度“估计实现自适应步长</h3>
<p>分位数估计器在更新的时候，其更新步长与这个density_变量直接相关，现在我们来看下webrtc的实现是如何做到自适应步长的。</p>
<blockquote>
<p>density_[j]表示: 当前分位数估计点附近的”局部密度估计“，近似表示这个log频谱点的概率密度函数值。</p>
</blockquote>
<p>现实场景中，噪声频点能量分布是变化的，当低噪声变化时，噪声频点能量分布密集；当语音变化时，噪声频点能量分布稀疏。因此需要估计分布密度，以调整步长动态性，防止在高密度或低密度区域过度抖动或者太慢反应</p>
<ul>
<li>density_是如何计算的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Update</span> <span class="n">density</span> <span class="n">estimate</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">float</span> <span class="n">kWidth</span> <span class="o">=</span> <span class="mf">0.01</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">float</span> <span class="n">kOneByWidthPlus2</span> <span class="o">=</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="n">f</span> <span class="o">*</span> <span class="n">kWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">log_spectrum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_quantile_</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">kWidth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">counter_</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">*</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">kOneByWidthPlus2</span><span class="p">)</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">                <span class="n">one_by_counter_plus_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>这是一种滑动窗口统计估计法：</p>
<table>
  <thead>
      <tr>
          <th>步骤</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>fabs(&hellip;) &lt; kWidth</td>
          <td>当前观测值是否落在估计值 ±0.01 范围内</td>
      </tr>
      <tr>
          <td>kOneByWidthPlus2 = 1 / (2 × 0.01)</td>
          <td>这是一个常数权重（经验值）</td>
      </tr>
      <tr>
          <td>density_[j] = (&hellip;)</td>
          <td>使用 指数滑动平均 来更新密度值</td>
      </tr>
      <tr>
          <td>最终的效果是：</td>
          <td></td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>density_[j] 趋近于“单位宽度窗口”内命中次数的平均值 —— 表示在分位点附近的信号频谱密集程度。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">float</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="n">f</span> <span class="err">?</span> <span class="mf">40.</span><span class="n">f</span> <span class="o">/</span> <span class="n">density_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span> <span class="mf">40.</span><span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">float</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">one_by_counter_plus_1</span><span class="p">;</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>density_变量直接影响了分位数估计的步长，也就是说</p>
<ul>
<li>如果 density_ 高：说明这个频率点的能量比较“稳定”，变化较小 → delta 会小 → 更新变慢</li>
<li>如果 density_ 低：说明这个点的能量波动大 → delta 会大 → 更新更激进</li>
</ul>
<p>总结就是，density_ 表示当前分位点附近的局部频谱密度，用于调节更新速率，帮助 WebRTC 实现稳定、鲁棒、快速收敛的底噪估计。</p>
<p>Ok，这就是WebRTC中基于分位数噪声估计的全部了。总的来说，基于分位数的噪声估计算法原理简单，但WebRTC的实现有很多巧妙的地方，即保证了效果，也提高了效率，绝对是工程精华值得好好研究。</p>
<p>接下来会继续分享WebRTC语音降噪部分代码，希望对有兴趣的朋友有帮助。</p>
]]></content:encoded>
    </item>
    <item>
      <title>程序员的基本修养之代码编译</title>
      <link>https://lyapple2008.github.io/posts/202503/2025-03-27-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 27 Mar 2025 22:43:58 +0800</pubDate>
      <guid>https://lyapple2008.github.io/posts/202503/2025-03-27-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/</guid>
      <description>&lt;h1 id=&#34;程序员的基本修养之代码编译&#34;&gt;程序员的基本修养之代码编译&lt;/h1&gt;
&lt;p&gt;| 代码编译过程介绍，避坑指南，一些常用代码查看工具使用介绍&lt;/p&gt;
&lt;h2 id=&#34;预处理&#34;&gt;预处理&lt;/h2&gt;
&lt;h3 id=&#34;1预处理的作用&#34;&gt;1.预处理的作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;宏替换&lt;/strong&gt;：&lt;br&gt;
替换 #define 定义的宏。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define PI 3.14159
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;circle_area&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 替换后：3.14159 * radius * radius
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;头文件包含&lt;/strong&gt; &lt;br&gt;
替换 #include 指令为头文件的内容。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="程序员的基本修养之代码编译">程序员的基本修养之代码编译</h1>
<p>| 代码编译过程介绍，避坑指南，一些常用代码查看工具使用介绍</p>
<h2 id="预处理">预处理</h2>
<h3 id="1预处理的作用">1.预处理的作用</h3>
<p><strong>宏替换</strong>：<br>
替换 #define 定义的宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define PI 3.14159
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">double</span> <span class="nf">circle_area</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">PI</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span> <span class="c1">// 替换后：3.14159 * radius * radius
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>头文件包含</strong> <br>
替换 #include 指令为头文件的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;// 替换为 &lt;iostream&gt; 文件的完整内容</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>条件编译</strong> <br>
根据条件选择性地编译代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#ifdef DEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Debug mode is on&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>宏展开</strong> <br>
处理函数式宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define SQUARE(x) ((x) * (x))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">SQUARE</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 替换为 ((5) * (5))
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>注释删除</strong> <br>
移除源代码中的注释内容。</p>
<h3 id="2查看预处理结果">2.查看预处理结果</h3>
<p>通过 编译器选项 可以仅执行预处理步骤。例如gcc/clang：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl">g++ -E main.cpp -o main.i</span></span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>-E 选项表示仅执行预处理。</li>
<li>输出文件 main.i 包含预处理后的源代码。
<img src="/images/2025-03-27/001.png"/>
cmake可以通过添加配置保存中间产物</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-CMake" data-lang="CMake"><span class="line"><span class="cl"><span class="nb">set_target_properties</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PROPERTIES</span> <span class="s">COMPILE_FLAGS</span> <span class="s2">&#34;-save-temps=obj&#34;</span><span class="p">)</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p>注：一些复杂的宏操作可以通过这种方式确定最终展开后的形式</p>
<h3 id="3预处理注意事项">3.预处理注意事项</h3>
<p><strong>宏展开陷阱</strong> <br>
注意宏的嵌套展开可能引发意外行为，用括号保护表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define ADD(x, y) ((x) + (y))</span></span></span></code></pre></td></tr></table>
</div>
</div>
<p><strong>头文件滥用</strong> <br>
导出了所有头文件并加入了搜索路径，当存在多个同名头文件时，可能会引起一些诡异的编译问题，或者运行时崩溃</p>
<ul>
<li>头文件的搜索顺序
1.搜索当前目录（一般是#include &ldquo;header.h&rdquo;，双引号方式引用头文件）
2.通过-I指定的目录，多个目录按加入的顺序搜索
3.标准系统目录</li>
</ul>
<h2 id="编译">编译</h2>
<p>| 编译是从源文件（<em>.c/</em>.cpp）生成目标文件（*.o）的过程</p>
<h3 id="q1目标文件里面包含了哪些信息">Q1：目标文件里面包含了哪些信息？</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl">llvm-objdump -s /path/to/objfile <span class="c1"># 显示目标文件中所有Section的内容</span></span></span></code></pre></td></tr></table>
</div>
</div>
<img src="/images/2025-03-27/002.png"/>
<h4 id="1目标文件类型目标架构">1.目标文件类型、目标架构</h4>
<p>查看命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl"><span class="c1"># 可以直接使用ndk里面的工具，目标文件/静态库/动态库/可执行文件都可以查看</span>
</span></span><span class="line"><span class="cl">llvm-readelf -h 目标文件</span></span></code></pre></td></tr></table>
</div>
</div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">File: /Users/marshall/Workspace/projects/test_compile/build/lib_src/CMakeFiles/lib_src.dir/conv1d.o
</span></span><span class="line"><span class="cl">Format: Mach-O arm64
</span></span><span class="line"><span class="cl">Arch: aarch64
</span></span><span class="line"><span class="cl">AddressSize: 64bit
</span></span><span class="line"><span class="cl">MachHeader {
</span></span><span class="line"><span class="cl">  Magic: Magic64 (0xFEEDFACF)
</span></span><span class="line"><span class="cl">  CpuType: Arm64 (0x100000C)
</span></span><span class="line"><span class="cl">  CpuSubType: CPU_SUBTYPE_ARM64_ALL (0x0)
</span></span><span class="line"><span class="cl">  FileType: Relocatable (0x1)
</span></span><span class="line"><span class="cl">  NumOfLoadCommands: 4
</span></span><span class="line"><span class="cl">  SizeOfLoadCommands: 520
</span></span><span class="line"><span class="cl">  Flags [ (0x2000)
</span></span><span class="line"><span class="cl">    MH_SUBSECTIONS_VIA_SYMBOLS (0x2000)
</span></span><span class="line"><span class="cl">  ]
</span></span><span class="line"><span class="cl">  Reserved: 0x0
</span></span><span class="line"><span class="cl">}</span></span></code></pre></td></tr></table>
</div>
</div>
<h4 id="2只读内容存在__text段">2.只读内容存在__TEXT段</h4>
<h5 id="a__text节保存了编译后的机器码">a.__text节保存了编译后的机器码:</h5>
<p>内容：源代码编译后的二进制机器指令，对应程序的函数和逻辑
查看命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl">llvm-objdump -d 目标文件</span></span></code></pre></td></tr></table>
</div>
</div>
<p>注：通过查看中间产物汇编文件（*.s）可以初步分析是否值得做 <br>
比如通过查看conv1d.s文件，发现已经做了循环展开，就不需要在c代码上手动做循环展开了（NEON类的SIMD在代码编译是否会进行编译优化待确定）</p>
<h5 id="b__cstring节保存了字符串">b.__cstring节保存了字符串</h5>
<h5 id="c__const节保存了学常量">c.__const节保存了学常量</h5>
<h4 id="3全局变量和静态变量保存在__data段">3.全局变量和静态变量保存在__DATA段</h4>
<p>nm命令介绍
nm命令可以用来分析二进制分析的符号信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl"><span class="c1"># -A 选项在符号名前附加文件名，适用于分析静态库（.a）：</span>
</span></span><span class="line"><span class="cl">nm -A 静态库路径</span></span></code></pre></td></tr></table>
</div>
</div>
<img src="/images/2025-03-27/003.png"/>
<img src="/images/2025-03-27/004.png"/>
注：该命令可以用来辅助分析Undefined symbol一类的编译问题
<h3 id="q2同一份代码保持编译参数不变的情况两次编译最终的目标文件是否是一样的">Q2：同一份代码，保持编译参数不变的情况，两次编译最终的目标文件是否是一样的？</h3>
<ul>
<li>通常一致的场景
如果满足以下条件，两次编译的目标文件大概率相同：</li>
</ul>
<ol>
<li>代码完全不变：未修改任何源码文件（包括头文件）</li>
<li>编译参数严格一致：包括优化级别（如 -O2）、调试选项（如 -g）、路径参数（如 -I）等</li>
<li>编译器版本一致：同一版本的编译器（如 GCC 12.3）和链接器</li>
<li>环境无干扰：<br>
a.无时间戳或随机化因素嵌入二进制文件（如代码中未使用 <strong>DATE</strong>、<strong>TIME</strong> 宏）<br>
b.编译路径和文件系统结构相同</li>
</ol>
<ul>
<li>可能导致不一致的例外情况</li>
</ul>
<ol>
<li>时间戳或随机化因素 <br>
若源码使用 <strong>DATE</strong>、<strong>TIME</strong> 等宏，编译后生成的二进制文件会包含编译时间戳，导致两次编译结果不同。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Build Time: %s %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__DATE__</span><span class="p">,</span> <span class="n">__TIME__</span><span class="p">);</span> <span class="c1">// 每次编译结果不同
</span></span></span></code></pre></td></tr></table>
</div>
</div>
<ol start="2">
<li>调试信息中的路径差异 <br>
调试信息（.debug_line 段）默认包含源码绝对路径。若两次编译的源码目录不同，目标文件会不同。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl"><span class="c1"># 第一次编译路径：/home/user/project/</span>
</span></span><span class="line"><span class="cl">gcc -g main.c -o main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 第二次编译路径：/tmp/build/</span>
</span></span><span class="line"><span class="cl">gcc -g main.c -o main  <span class="c1"># 调试信息中的路径不同，目标文件哈希值不同</span></span></span></code></pre></td></tr></table>
</div>
</div>
<h2 id="链接">链接</h2>
<p>| 链接就是把所有目标文件合并到起，同时目标文件中在未知的地址（如在其它文件中实现的函数调用）替换成最终的地址</p>
<img src="/images/2025-03-27/005.png"/>
注：左侧是目标文件main.o，右侧是最终的可执行程序main
``` Shell
llvm-objdump -d 目标文件
```
<h3 id="动态库与静态库对比">动态库与静态库对比</h3>
<img src="/images/2025-03-27/006.png"/>
<p>macos环境下查看依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">otool</span> <span class="o">-</span><span class="n">L</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">binary</span></span></span></code></pre></td></tr></table>
</div>
</div>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">main:
</span></span><span class="line"><span class="cl">	@rpath/liblib_src.dylib (compatibility version 0.0.0, current version 0.0.0)
</span></span><span class="line"><span class="cl">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1351.0.0)</span></span></code></pre></td></tr></table>
</div>
</div>
<p>注：@rpath 会根据不同应用的配置解析到对应的目录</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
